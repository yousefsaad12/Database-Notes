>[!SUMMARY] Table of Contents

>    - [[Database#Rami Course(https://whispering-narcissus-931.notion.site/ITI-Database-Course-ByAmr-112de9a262fa80a8bff9ed9233477068)|Rami Course(https://whispering-narcissus-931.notion.site/ITI-Database-Course-ByAmr-112de9a262fa80a8bff9ed9233477068)]]
>- [[Database#Lecture 1|Lecture 1]]
>        - [[Database#Disadvantages of read and write from files in database|Disadvantages of read and write from files in database]]
>        - [[Database#Advantages of DB System|Advantages of DB System]]
>        - [[Database#Disadvantages of DB System|Disadvantages of DB System]]
>    - [[Database#Entity Relationship Diagram Concepts|Entity Relationship Diagram Concepts]]
>        - [[Database#Basic constructs of the ER model:|Basic constructs of the ER model:]]
>        - [[Database#Summary:|Summary:]]
>        - [[Database#Summary:|Summary:]]
>    - [[Database#Database Keys|Database Keys]]
>    - [[Database#Key Differences|Key Differences]]
>    - [[Database#Simple Rules|Simple Rules]]
>- [[Database#Lecture 2|Lecture 2]]
>    - [[Database#Mapping|Mapping]]
>    - [[Database#SQL Language Categories|SQL Language Categories]]
>    - [[Database#The Five Categories of SQL Commands|The Five Categories of SQL Commands]]
>        - [[Database#1. DDL - Data Definition Language|1. DDL - Data Definition Language]]
>        - [[Database#2. DML - Data Manipulation Language|2. DML - Data Manipulation Language]]
>        - [[Database#3. DCL - Data Control Language|3. DCL - Data Control Language]]
>        - [[Database#4. DQL - Data Query Language|4. DQL - Data Query Language]]
>        - [[Database#5. TCL - Transaction Control Language|5. TCL - Transaction Control Language]]
>- [[Database#Lecture 3|Lecture 3]]
>    - [[Database#Joins|Joins]]
>    - [[Database#Join Types|Join Types]]
>        - [[Database#1. Cross Join|1. Cross Join]]
>        - [[Database#2. Inner Join|2. Inner Join]]
>        - [[Database#3. Outer Joins|3. Outer Joins]]
>        - [[Database#4. Self Join|4. Self Join]]
>    - [[Database#String Operations|String Operations]]
>        - [[Database#NULL Handling|NULL Handling]]
>        - [[Database#Concatenation|Concatenation]]
>    - [[Database#Pattern Matching with LIKE|Pattern Matching with LIKE]]
>    - [[Database#Ordering Results|Ordering Results]]
>    - [[Database#Complex Query Examples|Complex Query Examples]]
>        - [[Database#Employee Projects with Hours|Employee Projects with Hours]]
>        - [[Database#Employee Projects with Department|Employee Projects with Department]]
>        - [[Database#Update with Join|Update with Join]]
>    - [[Database#Steps of Database Normalization|Steps of Database Normalization]]
>    - [[Database#Normalization Process Flow|Normalization Process Flow]]
>    - [[Database#Detailed Steps|Detailed Steps]]
>        - [[Database#Step 1: Unnormalized → First Normal Form (1NF)|Step 1: Unnormalized → First Normal Form (1NF)]]
>        - [[Database#Step 2: 1NF → Second Normal Form (2NF)|Step 2: 1NF → Second Normal Form (2NF)]]
>        - [[Database#Step 3: 2NF → Third Normal Form (3NF)|Step 3: 2NF → Third Normal Form (3NF)]]
>    - [[Database#Summary|Summary]]
>- [[Database#Lecture 4|Lecture 4]]
>    - [[Database#SQL Aggregate Functions, Subqueries & Set Operations|SQL Aggregate Functions, Subqueries & Set Operations]]
>    - [[Database#Aggregate Functions|Aggregate Functions]]
>        - [[Database#Basic Aggregate Examples|Basic Aggregate Examples]]
>        - [[Database#GROUP BY Examples|GROUP BY Examples]]
>        - [[Database#HAVING Clause|HAVING Clause]]
>        - [[Database#NULL Handling in Aggregates|NULL Handling in Aggregates]]
>    - [[Database#SQL Query Execution Order|SQL Query Execution Order]]
>    - [[Database#Subqueries|Subqueries]]
>        - [[Database#Basic Subquery|Basic Subquery]]
>        - [[Database#Subquery in SELECT|Subquery in SELECT]]
>        - [[Database#Subquery with IN|Subquery with IN]]
>        - [[Database#Better Alternative with JOIN|Better Alternative with JOIN]]
>        - [[Database#Subquery in DML|Subquery in DML]]
>    - [[Database#Set Operations|Set Operations]]
>        - [[Database#UNION vs UNION ALL|UNION vs UNION ALL]]
>        - [[Database#INTERSECT|INTERSECT]]
>        - [[Database#EXCEPT|EXCEPT]]
>        - [[Database#Multiple Column Operations|Multiple Column Operations]]
>    - [[Database#Quick Reference|Quick Reference]]
>- [[Database#Lecture 5|Lecture 5]]
>    - [[Database#🟦 Basic SQL Queries|🟦 Basic SQL Queries]]
>    - [[Database#🟦 Filtering by Full Name|🟦 Filtering by Full Name]]
>        - [[Database#✅ Option 1: Expression in WHERE|✅ Option 1: Expression in WHERE]]
>        - [[Database#✅ Option 2: Subquery|✅ Option 2: Subquery]]
>    - [[Database#🟩 SQL Execution Order|🟩 SQL Execution Order]]
>    - [[Database#🟪 Object Structure Format|🟪 Object Structure Format]]
>    - [[Database#📄 Copying Tables|📄 Copying Tables]]
>        - [[Database#1. Copy Structure + Data|1. Copy Structure + Data]]
>        - [[Database#2. Copy Structure Only|2. Copy Structure Only]]
>        - [[Database#3. Copy Data Only (to existing table)|3. Copy Data Only (to existing table)]]
>    - [[Database#📊 Using HAVING Without GROUP BY|📊 Using HAVING Without GROUP BY]]
>        - [[Database#Ranking Functions in SQL|Ranking Functions in SQL]]
>        - [[Database#1. ROWNUMBER()|1. ROWNUMBER()]]
>        - [[Database#2. DENSERANK()|2. DENSERANK()]]
>        - [[Database#3. NTILE(n)|3. NTILE(n)]]
>        - [[Database#4. RANK()|4. RANK()]]
>        - [[Database#1. Select the Third Minimum Salary:|1. Select the Third Minimum Salary:]]
>        - [[Database#2. Select All Rows with Rank Less Than or Equal to 4:|2. Select All Rows with Rank Less Than or Equal to 4:]]
>        - [[Database#3. Select Rows with Rank Exactly Equal to 4:|3. Select Rows with Rank Exactly Equal to 4:]]
>        - [[Database#4. Divide Employees into 4 Groups and Get Minimum Salary from Each Group:|4. Divide Employees into 4 Groups and Get Minimum Salary from Each Group:]]
>        - [[Database#5. Select All Rows in Group 1:|5. Select All Rows in Group 1:]]
>        - [[Database#Examples Using Partition in Ranking Functions:|Examples Using Partition in Ranking Functions:]]
>    - [[Database#🔀 Conditional Logic|🔀 Conditional Logic]]
>        - [[Database#✅ CASE|✅ CASE]]
>        - [[Database#✅ IIF|✅ IIF]]
>    - [[Database#🕗 Date & Time Formatting|🕗 Date & Time Formatting]]
>        - [[Database#📆 Convert with CONVERT|📆 Convert with CONVERT]]
>        - [[Database#🎨 Format with FORMAT()|🎨 Format with FORMAT()]]
>- [[Database#Lecture 6|Lecture 6]]
>- [[Database#SQL Server Database Architecture & Integrity|SQL Server Database Architecture & Integrity]]
>    - [[Database#Physical Representation|Physical Representation]]
>        - [[Database#File Types|File Types]]
>        - [[Database#Database Creation Example|Database Creation Example]]
>    - [[Database#Logical Representation|Logical Representation]]
>        - [[Database#Filegroups|Filegroups]]
>    - [[Database#Data Pages|Data Pages]]
>    - [[Database#Benefit of Parallel Disk I/O|Benefit of Parallel Disk I/O]]
>        - [[Database#How It Works|How It Works]]
>        - [[Database#Implementation|Implementation]]
>    - [[Database#Performance Benefits of Filegroups|Performance Benefits of Filegroups]]
>        - [[Database#Key Advantages|Key Advantages]]
>    - [[Database#Create a Computed Column, Sparse, is Persisted|Create a Computed Column, Sparse, is Persisted]]
>        - [[Database#Computed Columns|Computed Columns]]
>        - [[Database#PERSISTED vs Non-PERSISTED|PERSISTED vs Non-PERSISTED]]
>        - [[Database#Sparse Columns|Sparse Columns]]
>        - [[Database#When to Use Sparse|When to Use Sparse]]
>    - [[Database#Reasons for Using Schemas|Reasons for Using Schemas]]
>        - [[Database#1. Unique Object Names|1. Unique Object Names]]
>        - [[Database#2. Logical Grouping|2. Logical Grouping]]
>        - [[Database#3. Permission Management|3. Permission Management]]
>        - [[Database#Creating and Managing Schemas|Creating and Managing Schemas]]
>    - [[Database#Synonyms in SQL Server|Synonyms in SQL Server]]
>        - [[Database#Purpose|Purpose]]
>        - [[Database#Creating and Using Synonyms|Creating and Using Synonyms]]
>        - [[Database#Benefits|Benefits]]
>        - [[Database#Managing Synonyms|Managing Synonyms]]
>    - [[Database#Deleting Data in Databases or Tables|Deleting Data in Databases or Tables]]
>        - [[Database#Comparison of Deletion Methods|Comparison of Deletion Methods]]
>        - [[Database#Detailed Examples|Detailed Examples]]
>            - [[Database#DROP TABLE|DROP TABLE]]
>            - [[Database#DELETE FROM|DELETE FROM]]
>            - [[Database#TRUNCATE TABLE|TRUNCATE TABLE]]
>        - [[Database#Clearing Specific Column Data|Clearing Specific Column Data]]
>    - [[Database#Database Integrity (Constraints)|Database Integrity (Constraints)]]
>        - [[Database#1. Domain Integrity (Range of Values)|1. Domain Integrity (Range of Values)]]
>        - [[Database#2. Entity Integrity (Uniqueness)|2. Entity Integrity (Uniqueness)]]
>        - [[Database#3. Referential Integrity (Relationships)|3. Referential Integrity (Relationships)]]
>        - [[Database#Comprehensive Example|Comprehensive Example]]
>        - [[Database#Managing Constraints After Table Creation|Managing Constraints After Table Creation]]
>        - [[Database#Foreign Key Cascade Options|Foreign Key Cascade Options]]
>    - [[Database#Managing Rules, Defaults, and Data Types in SQL|Managing Rules, Defaults, and Data Types in SQL]]
>        - [[Database#Creating and Managing Rules|Creating and Managing Rules]]
>        - [[Database#Creating and Managing Defaults|Creating and Managing Defaults]]
>        - [[Database#Creating User-Defined Data Types|Creating User-Defined Data Types]]
>        - [[Database#Rules vs Constraints Comparison|Rules vs Constraints Comparison]]
>        - [[Database#Key Points|Key Points]]
>        - [[Database#Finding Rules and Defaults|Finding Rules and Defaults]]
>- [[Database#Lecture 7|Lecture 7]]
>- [[Database#SQL Server Variables, Control Flow & Functions - Summary|SQL Server Variables, Control Flow & Functions - Summary]]
>    - [[Database#Variables|Variables]]
>        - [[Database#Local Variables|Local Variables]]
>        - [[Database#Global Variables (System)|Global Variables (System)]]
>        - [[Database#Dynamic SQL|Dynamic SQL]]
>    - [[Database#Control Flow Statements|Control Flow Statements]]
>        - [[Database#IF Statement|IF Statement]]
>        - [[Database#Existence Checks|Existence Checks]]
>        - [[Database#TRY...CATCH|TRY...CATCH]]
>        - [[Database#WHILE Loop|WHILE Loop]]
>        - [[Database#CASE Statement|CASE Statement]]
>        - [[Database#Conditional Functions|Conditional Functions]]
>    - [[Database#Transactions|Transactions]]
>        - [[Database#Types|Types]]
>        - [[Database#Example|Example]]
>    - [[Database#Built-in Functions|Built-in Functions]]
>        - [[Database#NULL Functions|NULL Functions]]
>        - [[Database#String Functions|String Functions]]
>        - [[Database#Date Functions|Date Functions]]
>        - [[Database#Conversion Functions|Conversion Functions]]
>        - [[Database#Aggregate Functions|Aggregate Functions]]
>        - [[Database#Window Functions|Window Functions]]
>        - [[Database#Mathematical Functions|Mathematical Functions]]
>    - [[Database#User-Defined Functions|User-Defined Functions]]
>        - [[Database#1. Scalar Function (Returns single value)|1. Scalar Function (Returns single value)]]
>        - [[Database#2. Inline Table-Valued Function|2. Inline Table-Valued Function]]
>        - [[Database#3. Multi-Statement Table-Valued Function|3. Multi-Statement Table-Valued Function]]
>    - [[Database#Security Best Practices|Security Best Practices]]
>        - [[Database#SQL Injection Prevention|SQL Injection Prevention]]
>        - [[Database#Key Points|Key Points]]
>    - [[Database#Quick Examples|Quick Examples]]
>        - [[Database#Get Employee with Longest Name|Get Employee with Longest Name]]
>        - [[Database#Window Function Example|Window Function Example]]
>- [[Database#Lecture 8|Lecture 8]]
>    - [[Database#SQL Server Indexes - Summary|SQL Server Indexes - Summary]]
>    - [[Database#Data Storage Basics|Data Storage Basics]]
>        - [[Database#Data Pages|Data Pages]]
>    - [[Database#Table Storage Types|Table Storage Types]]
>        - [[Database#1. Heap (No Primary Key)|1. Heap (No Primary Key)]]
>        - [[Database#2. Clustered Index (With Primary Key)|2. Clustered Index (With Primary Key)]]
>    - [[Database#Index Types|Index Types]]
>        - [[Database#Clustered Index|Clustered Index]]
>        - [[Database#Non-Clustered Index|Non-Clustered Index]]
>    - [[Database#Search Process|Search Process]]
>        - [[Database#Clustered Index Search|Clustered Index Search]]
>        - [[Database#Non-Clustered Index Search|Non-Clustered Index Search]]
>    - [[Database#Automatic Index Creation|Automatic Index Creation]]
>        - [[Database#Primary Key Constraint|Primary Key Constraint]]
>        - [[Database#Unique Constraint|Unique Constraint]]
>    - [[Database#Performance Comparison|Performance Comparison]]
>    - [[Database#Detailed Comparison Table|Detailed Comparison Table]]
>    - [[Database#Best Practices|Best Practices]]
>        - [[Database#When to Use Clustered Index|When to Use Clustered Index]]
>        - [[Database#When to Use Non-Clustered Index|When to Use Non-Clustered Index]]
>        - [[Database#When to Avoid Indexes|When to Avoid Indexes]]
>    - [[Database#Index Management Examples|Index Management Examples]]
>        - [[Database#Creating Indexes|Creating Indexes]]
>        - [[Database#Viewing Indexes|Viewing Indexes]]
>        - [[Database#Dropping Indexes|Dropping Indexes]]
>    - [[Database#Key Takeaways|Key Takeaways]]
>    - [[Database#Quick Decision Guide|Quick Decision Guide]]
>    - [[Database#SQL Server Views - Summary|SQL Server Views - Summary]]
>    - [[Database#What is a View?|What is a View?]]
>    - [[Database#View Types|View Types]]
>        - [[Database#1. Standard View|1. Standard View]]
>        - [[Database#2. Partitioned View|2. Partitioned View]]
>        - [[Database#3. Indexed View|3. Indexed View]]
>    - [[Database#View Features|View Features]]
>        - [[Database#Joining Tables in Views|Joining Tables in Views]]
>        - [[Database#Combining Views|Combining Views]]
>        - [[Database#Encrypted Views|Encrypted Views]]
>        - [[Database#Schema Binding|Schema Binding]]
>    - [[Database#DML Operations on Views|DML Operations on Views]]
>        - [[Database#Single Table Views|Single Table Views]]
>        - [[Database#Multi-Table Views|Multi-Table Views]]
>        - [[Database#WITH CHECK OPTION|WITH CHECK OPTION]]
>    - [[Database#Schema Name Requirements|Schema Name Requirements]]
>    - [[Database#Performance Considerations|Performance Considerations]]
>        - [[Database#Standard Views|Standard Views]]
>        - [[Database#Indexed Views|Indexed Views]]
>    - [[Database#Best Practices|Best Practices]]
>        - [[Database#When to Use Views|When to Use Views]]
>        - [[Database#When to Use Indexed Views|When to Use Indexed Views]]
>        - [[Database#Security Best Practices|Security Best Practices]]
>    - [[Database#Common View Patterns|Common View Patterns]]
>        - [[Database#Filtering Data|Filtering Data]]
>        - [[Database#Aggregating Data|Aggregating Data]]
>        - [[Database#Joining Related Tables|Joining Related Tables]]
>        - [[Database#Column Transformation|Column Transformation]]
>    - [[Database#View Management|View Management]]
>        - [[Database#Viewing View Definition|Viewing View Definition]]
>        - [[Database#Modifying Views|Modifying Views]]
>        - [[Database#Dropping Views|Dropping Views]]
>    - [[Database#Quick Reference|Quick Reference]]
>        - [[Database#Key Limitations|Key Limitations]]
>- [[Database#Lecture 9|Lecture 9]]
>    - [[Database#Stored Procedures|Stored Procedures]]
>        - [[Database#Types of Stored Procedures|Types of Stored Procedures]]
>    - [[Database#Triggers|Triggers]]
>        - [[Database#Types of Table-Level Triggers|Types of Table-Level Triggers]]
>        - [[Database#1. AFTER INSERT Trigger|1. AFTER INSERT Trigger]]
>        - [[Database#2. AFTER UPDATE Trigger|2. AFTER UPDATE Trigger]]
>        - [[Database#3. INSTEAD OF DELETE Trigger|3. INSTEAD OF DELETE Trigger]]
>        - [[Database#4. Read-Only Table Trigger|4. Read-Only Table Trigger]]
>        - [[Database#Trigger Functionalities|Trigger Functionalities]]
>        - [[Database#a. Update-Specific Functionality|a. Update-Specific Functionality]]
>        - [[Database#b. Enable and Disable Triggers|b. Enable and Disable Triggers]]
>        - [[Database#c. Using the INSERTED and DELETED Tables|c. Using the INSERTED and DELETED Tables]]
>        - [[Database#d. Conditional DELETE Trigger|d. Conditional DELETE Trigger]]
>        - [[Database#e. Tracking Changes in a History Table|e. Tracking Changes in a History Table]]
>        - [[Database#f. Using the OUTPUT Keyword in DML Statements|f. Using the OUTPUT Keyword in DML Statements]]
>- [[Database#Lecture 10|Lecture 10]]
>    - [[Database#Cursor|Cursor]]
>- [[Database#Topics|Topics]]
>- [[Database#Exams|Exams]]


## [Rami Course](https://whispering-narcissus-931.notion.site/ITI-Database-Course-By_Amr-112de9a262fa80a8bff9ed9233477068)


# Lecture 1

**Database**: A collection of related data.

**Database Management System (DBMS)**: A software package/ system to facilitate the creation and maintenance of a computerized database.(model introduced in 1970 IBM but RDBMS appears in1980)

### Disadvantages of read and write from files in database

1- Difficaluty of search.

2- Low performance.

3- Separated copies (every developer take copy and the others can not see the updates).

4- No relationships.

5- No DB integrity.

6- DB redundancy.

7- Long development time.

8- Security & permissions.

9- Constrains and rules.

10- No data quality every data received as text.

11- Manual backup & restore.

12- No standard.

13- Different integrations.


### Advantages of DB System

1- one standard.

2- metadata (data about data : discretion of data) and data.

3- columns has data types.

4- primary key.

5- foregin key.

6- centralized DB. **strong entity**: department, weak entity: entity that became not interest after deleting member for example entity family.

### Disadvantages of DB System

- It needs expertise to use
- DBMS itself is expensive
- The DBMS may be incompatible with any other available DBMS



## **Entity Relationship Diagram Concepts**

**⇒ Entity-Relationship Diagram (ERD)**

identifies information required by the business by displaying the relevant entities and the relationships between them.

### **Basic constructs of the ER model:**

**⇒ Entity**

An **entity** is any object, person, place, event, or concept about which data is stored in a database. Entities represent real-world things or concepts and are usually represented as tables in a database.

- **Examples**:
    - A **student** in a school database.
    - A **product** in an e-commerce database.
    - An **employee** in a company’s HR database.

In ER (Entity-Relationship) modeling, entities are typically depicted as rectangles.

- **Type**: Strong Entity & Weak Entity
    
- **Strong Entity Vs Weak Entity**
    
    In summary, a **strong entity** exists independently and has its own unique identifier, while a **weak entity** depends on a strong entity for identification and cannot exist without it.


![[Screenshot 2024-10-04 144509.png]]



=> Attributes :

- type : 

simple
 ![[Screenshot 2024-10-04 144547.png]]

composite
 ![[Screenshot 2024-10-04 144558.png]]

driven
 ![[Screenshot 2024-10-04 144609.png]]

multi-valued
 ![[Screenshot 2024-10-04 144620.png]]

complex:(multi-valued + composite).
 ![[Screenshot 2024-10-04 144630.png]]


⇒ Relationships
### Summary:

- **Unary Relationships** are simple and involve self-referencing within one table.

- **Binary Relationships** are the most common, involving two tables and can vary in cardinality (1:1, 1, or M).

- **Ternary Relationships** are more complex, involving three tables and typically requiring a junction table to handle many-to-many-to-many relationships.


⇒ Cardenality Constraint
### Summary:

- **One-to-One (1:1)** relationships link exactly one instance of one entity with one instance of another. It's common in cases of unique relationships.

- **One-to-Many (1)** relationships are used when one entity can be associated with multiple instances of another entity but not the other way around.

- **Many-to-Many (M)** relationships are the most complex, requiring a junction table to manage the associations between many instances of two entities.

⇒ Participation constraint:

- **Total Participation** ensures every instance of an entity must have a corresponding related instance, enforcing data integrity and completeness.

- **Partial Participation** allows for optional relationships where some instances may not participate, providing flexibility in data modeling.


## Database Keys 

| Key Type            | Definition                      | Notation            | Unique? | Example                    |
| ------------------- | ------------------------------- | ------------------- | ------- | -------------------------- |
| **Primary Key**     | Main identifier for records     | Underlined          | Yes     | StudentID                  |
| **Candidate Key**   | Could be primary key            | None                | Yes     | Email, Phone               |
| **Composite Key**   | 2+ attributes as primary key    | Multiple underlined | Yes     | (StudentID, CourseID)      |
| **Foreign Key**     | References another table's PK   | Dashed line/FK      | No      | StudentID in Enrollment    |
| **Super Key**       | Any unique combination          | None                | Yes     | (StudentID, Name)          |
| **Alternative Key** | Candidate keys not chosen as PK | None                | Yes     | Email (if StudentID is PK) |
| **Partial Key**     | Key part in weak entity         | Dashed underline    | No*     | RoomNumber in Room         |

*Not unique alone, needs owner entity's key

## Key Differences

**Primary vs Candidate**: Primary is the chosen one, Candidate are all options 

**Composite vs Primary**: Composite is just a multi-attribute primary key  

**Foreign vs Primary**: Foreign links tables, Primary identifies records 

**Super vs Candidate**: Super has extra attributes, Candidate is minimal 

**Alternative vs Primary**: Alternative are the unused candidate keys 

**Partial vs Primary**: Partial needs another key to work (weak entities only)

## Simple Rules

1. One primary key per table (required)
2. Primary key = unique + not null
3. Foreign key = creates table relationships
4. Weak entity = partial key + owner's primary key



---


# Lecture 2
## Mapping 

## SQL Language Categories

## The Five Categories of SQL Commands

### 1. DDL - Data Definition Language

**Purpose:** Metadata & Structure

| Command           | Description                     |     |
| ----------------- | ------------------------------- | --- |
| `CREATE TABLE`    | Define new table structure      |     |
| `CREATE VIEW`     | Create virtual table view       |     |
| `CREATE FUNCTION` | Define user functions           |     |
| `ALTER`           | Modify existing structure       |     |
| `DROP`            | Remove database objects         |     |
| `SELECT INTO`     | Create table from query results |     |
| `TRUNCATE`        |                                 |     |

### 2. DML - Data Manipulation Language

**Purpose:** Data Operations

|Command|Description|
|---|---|
|`INSERT`|Add new records|
|`UPDATE`|Modify existing records|
|`DELETE`|Remove records|
|`MERGE`|Upsert operations (insert/update)|

### 3. DCL - Data Control Language

**Purpose:** Security & Permissions

|Command|Description|
|---|---|
|`GRANT`|Give permissions to users|
|`DENY`|Explicitly deny permissions|
|`REVOKE`|Remove previously granted permissions|

### 4. DQL - Data Query Language

**Purpose:** Data Retrieval & Display

|Feature|Description|
|---|---|
|`SELECT`|Basic data retrieval|
|**Aggregate Functions**|`COUNT()`, `SUM()`, `AVG()`, `MIN()`, `MAX()`|
|**Grouping**|`GROUP BY`, `HAVING`|
|**Set Operations**|`UNION`, `INTERSECT`, `EXCEPT`|
|**Joins**|`INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, `FULL JOIN`|
|**Subqueries**|Nested SELECT statements|

### 5. TCL - Transaction Control Language

**Purpose:** Transaction Management

|Command|Description|
|---|---|
|`BEGIN TRANSACTION`|Start transaction block|
|`COMMIT`|Save transaction changes|
|`ROLLBACK`|Undo transaction changes|
|`SAVEPOINT`|Create rollback point|


---


# Lecture 3
## Joins 

## Join Types

### 1. Cross Join

Returns Cartesian product of two tables.

```sql
SELECT e.EmployeeName, d.DepartmentName
FROM Employee e CROSS JOIN Department d;
```

### 2. Inner Join

Returns records with matching values in both tables.

```sql
SELECT e.EmployeeName, d.DepartmentName
FROM Employee e
INNER JOIN Department d ON e.DepartmentID = d.DepartmentID;
```

### 3. Outer Joins

**Left Outer Join** - All records from left table + matched from right

```sql
SELECT e.EmployeeName, d.DepartmentName
FROM Employee e
LEFT JOIN Department d ON e.DepartmentID = d.DepartmentID;
```

**Right Outer Join** - All records from right table + matched from left

```sql
SELECT e.EmployeeName, d.DepartmentName
FROM Employee e
RIGHT JOIN Department d ON e.DepartmentID = d.DepartmentID;
```

**Full Outer Join** - All records from both tables

```sql
SELECT e.EmployeeName, d.DepartmentName
FROM Employee e
FULL OUTER JOIN Department d ON e.DepartmentID = d.DepartmentID;
```

### 4. Self Join

Join table with itself.

```sql
SELECT e1.EmployeeName AS Employee, e2.EmployeeName AS Manager
FROM Employee e1
INNER JOIN Employee e2 ON e1.ManagerID = e2.EmployeeID;
```

## String Operations

### NULL Handling

```sql
-- Replace NULL with default value
SELECT ISNULL(EmployeeName, 'NoName') FROM Employee;

-- Multi-level replacement
SELECT COALESCE(EmployeeName, LastName, 'Unknown') FROM Employee;
```

### Concatenation

```sql
-- Manual concatenation (handle NULLs)
SELECT EmployeeName + ' ' + CONVERT(VARCHAR(10), ISNULL(Salary, 0)) FROM Employee;

-- Safe concatenation (auto-converts types)
SELECT CONCAT(EmployeeName, ' ', Salary) FROM Employee;
```

## Pattern Matching with LIKE

`_` = single character, `%` = zero or more characters

```sql
-- Contains 'r'
WHERE EmployeeName LIKE '%r%'

-- Starts with 'r'
WHERE EmployeeName LIKE 'r%'

-- Second character is 'r'
WHERE EmployeeName LIKE '_r%'

-- Starts with 'o' or 'a', ends with 'r'
WHERE EmployeeName LIKE '[oa]%r'

-- Starts with anything except 'a', 'b', 'c'
WHERE EmployeeName LIKE '[^abc]%'

-- Character range a-h
WHERE EmployeeName LIKE '[a-h]%'

-- Literal special characters
WHERE EmployeeName LIKE '%[%]'    -- contains %
WHERE EmployeeName LIKE '%[_]%'   -- contains _
```

## Ordering Results

```sql
-- Order by column position
ORDER BY 2

-- Multiple columns
ORDER BY EmployeeName ASC, LastName DESC
```

## Complex Query Examples

### Employee Projects with Hours

```sql
SELECT e.EmployeeName, p.ProjectName, w.Hours
FROM Employee e
INNER JOIN Works_for w ON e.EmployeeID = w.EmployeeID
INNER JOIN Project p ON p.ProjectID = w.ProjectID;
```

### Employee Projects with Department

```sql
SELECT e.EmployeeName, p.ProjectName, w.Hours, d.DepartmentName
FROM Employee e
INNER JOIN Works_for w ON e.EmployeeID = w.EmployeeID
INNER JOIN Project p ON p.ProjectID = w.ProjectID
INNER JOIN Department d ON d.DepartmentID = e.DepartmentID;
```

### Update with Join

```sql
UPDATE Works_for
SET Hours += 10
FROM Employee e
INNER JOIN Works_for w ON e.EmployeeID = w.EmployeeID
WHERE e.Gender = 'M';
```

## Steps of Database Normalization


### **Normalization – Short Notes**

**Definition**:  
Normalization is the process of organizing data in a database to reduce redundancy and improve data integrity.

---

### **Why We Use Normalization**

1. **Avoid Redundancy**
    
    - Prevents storing the same data multiple times.
        
2. **Ensure Consistency**
    
    - Keeps data accurate and up-to-date across the system.
        
3. **Maintain Data Integrity**
    
    - Enforces valid relationships using keys and constraints.
        
4. **Prevent Anomalies**
    
    - Fixes common problems like:
        
    
    #### 🔹 **Insertion Anomaly**
    
    - Can’t add data because other required data is missing.  
        _Example: Can't insert a student without course info._
        
    
    #### 🔹 **Deletion Anomaly**
    
    - Deleting one piece of data accidentally removes important related data.  
        _Example: Deleting a course removes all student records._
        
    
    #### 🔹 **Update Anomaly**
    
    - Updating data in one place but not everywhere leads to inconsistency.  
        _Example: Changing a teacher’s name in one row but not others._
        
5. **Save Storage Space**
    
    - Reduces duplication, saving disk space.
        
6. **Simplify Maintenance**
    
    - Easier to modify or expand the database structure.
        


### **Types of Functional Dependency**:

---

🔹 **Full Functional Dependency**

- B depends on the **entire composite key** A.
    
- ✅ OK in 2NF.
    
- **Example**:  
    `(StudentID, CourseID) → Grade`
    

---

🔹 **Partial Dependency**

- B depends on **part of a composite key**.
    
- ❗ **Violates 2NF**.
    
- **Example**:  
    `StudentID → Name`  
    (when the full key is `(StudentID, CourseID)`)
    

---

🔹 **Transitive Dependency**

- A → B and B → C ⇒ A → C
    
- ❗ **Violates 3NF**.
    
- **Example**:  
    `StudentID → DeptID` and `DeptID → DeptName`  
    ⇒ `StudentID → DeptName`
    



Let me know if you'd like this added to your full normalization notes!
## Normalization Process Flow

```
┌─────────────────────┐
│   Table with        │
│   Multivalued       │
│   Attributes        │
└─────────────────────┘
           │
           ▼
┌─────────────────────┐     ┌─────────────────────┐
│                     │────▶│    Remove           │
│   First Normal      │     │    multivalued      │
│   Form (1NF)        │     │    attributes       │
│                     │     │                     │
└─────────────────────┘     └─────────────────────┘
           │
           ▼
┌─────────────────────┐     ┌─────────────────────┐
│                     │────▶│    Remove           │
│   Second Normal     │     │    partial          │
│   Form (2NF)        │     │    dependencies     │
│                     │     │                     │
└─────────────────────┘     └─────────────────────┘
           │
           ▼
┌─────────────────────┐     ┌─────────────────────┐
│                     │────▶│    Remove           │
│   Third Normal      │     │    transitive       │
│   Form (3NF)        │     │    dependencies     │
│                     │     │                     │
└─────────────────────┘     └─────────────────────┘
```

## Detailed Steps

### Step 1: Unnormalized → First Normal Form (1NF)

**Action:** Remove multivalued attributes

- Remove repeating groups, multivalued attributes, composite attribute

### Step 2: 1NF → Second Normal Form (2NF)

**Action:** Remove partial dependencies

- Table must already be in 1NF
- Remove attributes that depend on only part of a composite primary key => partially dependent attribute

### Step 3: 2NF → Third Normal Form (3NF)

**Action:** Remove transitive dependencies

- Table must already be in 2NF
- Remove non-key attributes that depend on other non-key attributes

## Summary

Each normalization step builds upon the previous one:

- **1NF**: Atomic values only
- **2NF**: No partial dependencies (1NF + full functional dependency)
- **3NF**: No transitive dependencies (2NF + direct dependency on primary key)

The goal is to minimize data redundancy and eliminate update anomalies while maintaining data integrity.



---

# Lecture 4

## SQL Aggregate Functions, Subqueries & Set Operations

## Aggregate Functions

**Functions:** `COUNT`, `MIN`, `MAX`, `SUM`, `AVG`

**Rule:** When selecting aggregate functions with other columns, use `GROUP BY`

### Basic Aggregate Examples

```sql
-- Count non-null values
SELECT COUNT(SSN) FROM Employees;

-- Count all rows (including nulls)
SELECT COUNT(*) FROM Employees;

-- Average salary
SELECT AVG(Salary) FROM Employees;
```

### GROUP BY Examples

```sql
-- Minimum salary by department
SELECT MIN(Salary), DepartmentID
FROM Employees
GROUP BY DepartmentID;

-- Count employees by gender
SELECT COUNT(SSN), Gender
FROM Employees
GROUP BY Gender;

-- Multiple grouping columns
SELECT SUM(Salary), DepartmentID, Address
FROM Employees
GROUP BY DepartmentID, Address;
```

### HAVING Clause

Filters groups after `GROUP BY` (unlike `WHERE` which filters rows before grouping)

```sql
-- Departments with total salary > 10000
SELECT SUM(Salary), DepartmentID
FROM Employees
GROUP BY DepartmentID
HAVING SUM(Salary) > 10000;

-- Addresses with more than 3 employees
SELECT MAX(Salary), Address
FROM Employees
WHERE DepartmentID IN (10, 30)
GROUP BY Address
HAVING COUNT(SSN) > 3;
```

### NULL Handling in Aggregates

```sql
-- AVG ignores NULLs automatically
SELECT AVG(DepartmentID) FROM Employees;

-- Treat NULLs as 0
SELECT AVG(ISNULL(DepartmentID, 0)) FROM Employees;

-- Manual average calculation
SELECT SUM(DepartmentID) / COUNT(*) FROM Employees;
```

## SQL Query Execution Order

## Subqueries

### Basic Subquery

```sql
-- Find employees earning above average
SELECT *
FROM Employees
WHERE Salary > (SELECT AVG(Salary) FROM Employees);
```

### Subquery in SELECT

```sql
-- Show average salary alongside each employee
SELECT *, (SELECT AVG(Salary) FROM Employees) AS AvgSalary
FROM Employees
WHERE Salary > (SELECT AVG(Salary) FROM Employees);
```

### Subquery with IN

```sql
-- Departments that have employees
SELECT DepartmentID
FROM Departments
WHERE DepartmentID IN (
    SELECT DISTINCT DepartmentID 
    FROM Employees 
    WHERE DepartmentID IS NOT NULL
);
```

### Better Alternative with JOIN

```sql
-- Same result, better performance
SELECT DISTINCT d.DepartmentName
FROM Departments d
INNER JOIN Employees e ON d.DepartmentID = e.DepartmentID;
```

### Subquery in DML

```sql
-- Update hours for male employees
UPDATE Works_For
SET HoursPerWeek = HoursPerWeek + 10
WHERE EmployeeID IN (
    SELECT EmployeeID 
    FROM Employees 
    WHERE Gender = 'M'
);
```

## Set Operations

Combine results from multiple queries. **Requirement:** Same number of columns in both queries.

### UNION vs UNION ALL

```sql
-- UNION: Removes duplicates, sorts results
SELECT FirstName FROM Employees
UNION
SELECT LastName FROM Employees;

-- UNION ALL: Keeps duplicates, no sorting
SELECT FirstName FROM Employees
UNION ALL
SELECT LastName FROM Employees;
```

### INTERSECT

Returns rows present in both queries.

```sql
-- Names that appear as both first and last names
SELECT FirstName FROM Employees
INTERSECT
SELECT LastName FROM Employees;
```

### EXCEPT

Returns rows in first query but not in second.

```sql
-- First names not used as last names
SELECT FirstName FROM Employees
EXCEPT
SELECT LastName FROM Employees;
```

### Multiple Column Operations

```sql
-- Compare full name combinations
SELECT FirstName, LastName FROM Employees
EXCEPT
SELECT FirstName, LastName FROM Managers;
```

## Quick Reference

| Operation | Purpose      | Duplicates | Sorting |
| --------- | ------------ | ---------- | ------- |
| UNION     | Combine sets | Removed    | Yes     |
| UNION ALL | Combine sets | Kept       | No      |
| INTERSECT | Common rows  | Removed    | Yes     |
| EXCEPT    | Difference   | Removed    | Yes     |


**Key Points:**

- `WHERE` filters rows, `HAVING` filters groups
- Subqueries can replace complex joins but may be slower
- Set operations require matching column counts and compatible types


---


# Lecture 5
## 🟦 Basic SQL Queries

```sql
-- Top 3 employees
SELECT TOP(3) * FROM Employees;

-- Top 3 employees with salary >= 1000
SELECT TOP(3) * FROM Employees WHERE Salary >= 1000;

-- Top 3 first names
SELECT TOP(3) EmployeeName FROM Employees;

-- Top 3 salaries (descending order)
SELECT TOP(3) Salary FROM Employees ORDER BY Salary DESC;

-- Top 4 with ties
SELECT TOP(4) WITH TIES * FROM Employees ORDER BY Salary;

-- Random GUID
SELECT NEWID();

-- Add random ID per row
SELECT *, NEWID() AS NewID FROM Employees;

-- Select 3 random employees
SELECT TOP(3) * FROM Employees ORDER BY NEWID();
```

## 🟦 Filtering by Full Name

> You can't use aliases directly in `WHERE`, so use one of these:

### ✅ Option 1: Expression in WHERE

```sql
SELECT Fname + ' ' + Lname AS Fullname
FROM Employees
WHERE Fname + ' ' + Lname = 'Amr Abdo';
```

### ✅ Option 2: Subquery

```sql
SELECT * FROM (
    SELECT Fname + ' ' + Lname AS Fullname
    FROM Employees
) AS NewTable
WHERE Fullname = 'Amr Abdo';
```

## 🟩 SQL Execution Order

```text
FROM → JOIN → ON → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → TOP
```

## 🟪 Object Structure Format

```text
[ServerName].[DatabaseName].[SchemaName].[ObjectName]
```

**Example:**

```sql
SELECT * FROM CompanyDB.dbo.Employees;
```

## 📄 Copying Tables

### 1. Copy Structure + Data

```sql
SELECT * INTO NewTable FROM Employees;
```

### 2. Copy Structure Only

```sql
SELECT * INTO EmptyTable FROM Employees WHERE 1=0;
```

### 3. Copy Data Only (to existing table)

```sql
INSERT INTO NewTable SELECT * FROM Employees;
```

## 📊 Using `HAVING` Without `GROUP BY`

```sql
SELECT SUM(Salary) AS TotalSalary
FROM Employees
HAVING COUNT(SSN) < 100;
```

### Ranking Functions in SQL

Ranking functions in SQL are used to assign a rank or number to each row within a partition of a result set. These functions can help analyze data by providing insights based on ordered values.

### 1. `ROW_NUMBER()`

- **Description**: This function assigns a unique sequential integer to rows within a partition of a result set. It starts at 1 and increments for each row.
- **Usage**: Use `ROW_NUMBER()` when you want to assign a unique number to each row based on a specific order.

```sql
SELECT *, ROW_NUMBER() OVER (ORDER BY Salary DESC) AS RN
FROM Employees;
```

- **Example Output**: If you have salaries like 5000, 4500, 4000, the output would rank them as 1, 2, 3.

### 2. `DENSE_RANK()`

- **Description**: Similar to `ROW_NUMBER()`, but it assigns the same rank to rows with equal values. The next rank will be the immediate next integer, without gaps.
- **Usage**: Use `DENSE_RANK()` when you want to group identical values and avoid gaps in ranking.

```sql
SELECT *, DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
FROM Employees;
```

- **Example Output**: For salaries like 5000, 4500, 4500, the output would be ranked as 1, 2, 2.

```scheme
SELECT *
FROM (SELECT *, ROW_NUMBER() OVER (ORDER BY Salary DESC) AS RN,
                DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
FROM Employees) AS NewTable
WHERE RN = 1;
```

### 3. `NTILE(n)`

- **Description**: This function divides the result set into `n` groups (or buckets) and assigns a group number to each row. The last group may contain fewer rows if the total number of rows isn't evenly divisible by `n`.
- **Usage**: Use `NTILE(n)` when you want to segment your data into a specified number of groups.

```sql
SELECT *, NTILE(4) OVER (ORDER BY Salary DESC) AS G
FROM Employees;
----------------------------------------------------------
SELECT *
FROM (SELECT *, NTILE(4) OVER (ORDER BY Salary DESC) AS G
FROM Employees) AS NewTable
WHERE G =1;
```

- **Example Output**: For 13 rows divided into 4 groups, you might get groups with sizes 4, 3, 3, and 3.

### 4. `RANK()`

- **Description**: Similar to `DENSE_RANK()`, but it leaves gaps in the ranking when there are ties. The next rank after a tie will skip numbers.
- **Usage**: Use `RANK()` when you need to acknowledge ties but want to maintain the ranking order.

```sql
SELECT *, RANK() OVER (ORDER BY Salary DESC) AS G
FROM Employees;
```

- **Example Output**: For salaries like 5000, 4500, 4500, 4000, the output would be ranked as 1, 2, 2, 4.

![[Screenshot 2024-10-20 155329.png]]

### 1. Select the Third Minimum Salary:

You can use either the `ROW_NUMBER()` function or a subquery approach to achieve this.

- **Using a Subquery**:

```sql
SELECT MIN(Salary)
FROM (
    SELECT TOP(3) Salary
    FROM Employees
    ORDER BY Salary DESC
) AS Table_One;
```

This query selects the third highest salary using a subquery that retrieves the top 3 salaries.

- **Using `ROW_NUMBER()`**:

```sql
SELECT *
FROM (
    SELECT *, ROW_NUMBER() OVER (ORDER BY Salary DESC) AS RN
    FROM Employees
) AS newtable
WHERE RN = 3;
```

This query uses the `ROW_NUMBER()` function to assign a rank to each salary and selects the third highest.

### 2. Select All Rows with Rank Less Than or Equal to 4:

This query uses the `DENSE_RANK()` function to return all rows with ranks 1 to 4, considering ties.

- **Using `DENSE_RANK()` with Rank <= 4**:

```sql
SELECT *
FROM (
    SELECT *, DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
    FROM Employee
) AS newtable
WHERE DR <= 4;
```

This query selects rows where the rank (based on salary) is less than or equal to 4, and rows with the same salary will have the same rank.

### 3. Select Rows with Rank Exactly Equal to 4:

This query returns only the rows with rank 4 (no rows below or above rank 4).

- **Using `DENSE_RANK()` with Rank = 4**:

```sql
SELECT *
FROM (
    SELECT *, DENSE_RANK() OVER (ORDER BY Salary DESC) AS DR
    FROM Employee
) AS newtable
WHERE DR = 4;
```

This query selects only the rows where the rank equals 4.

### 4. Divide Employees into 4 Groups and Get Minimum Salary from Each Group:

The `NTILE()` function is used here to divide the rows into four groups and select the minimum salary from each group.

- **Using `NTILE(4)` to Divide into Groups and Find Minimum Salary**:

```sql
SELECT MIN(Salary), G
FROM (
    SELECT *, NTILE(4) OVER (ORDER BY Salary DESC) AS G
    FROM Employee
) AS newtable
GROUP BY G;
```

This query divides the employees into 4 groups based on their salary and selects the minimum salary from each group.

### 5. Select All Rows in Group 1:

Using the `NTILE()` function to group rows, you can select all rows in a specific group, in this case, group 1.

- **Using `NTILE(4)` to Select All Rows in Group 1**:

```sql
SELECT *
FROM (
    SELECT *, NTILE(4) OVER (ORDER BY Salary DESC) AS G
    FROM Employee
) AS newtable
WHERE G = 1;
```

This query selects all employees who belong to group 1 after dividing the employees into 4 groups based on salary.

These queries demonstrate how to use SQL ranking functions (`ROW_NUMBER()`, `DENSE_RANK()`, `NTILE()`) effectively in practical scenarios for the **CompanyDB** database.

### Examples Using Partition in Ranking Functions:

1. **Assign Row Numbers Within Each Department:**
    
    ```sql
    SELECT *, ROW_NUMBER() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS RN
    FROM Employees;
    ```
    
    - This query divides the `Employees` table into groups based on `DepartmentID` (department number).
    - For each group, it assigns a row number starting from 1, ordered by `Salary` in descending order.
2. **Assign Dense Ranks Within Each Department:**
    
    ```sql
    SELECT *, DENSE_RANK() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS DR
    FROM Employees;
    ```
    
    - Similar to the above, but uses `DENSE_RANK()` to assign ranks based on salary.
    - Employees with the same salary will have the same rank.
3. **Select Maximum Salary for Each Department (Using Row Number):**
    
    ```sql
    SELECT *
    FROM (
        SELECT *, ROW_NUMBER() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS RN
        FROM Employees
    ) AS NewTable
    WHERE RN = 1;
    ```
    
    - This query selects the top employee (with the highest salary) in each department (`DepartmentID`) by filtering `ROW_NUMBER()` where `RN = 1`.
4. **Select Maximum Salary for Each Department (Using Dense Rank):**
    
    ```sql
    SELECT *
    FROM (
        SELECT *, DENSE_RANK() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS DR
        FROM Employees
    ) AS NewTable
    WHERE DR = 1;
    ```
    
    - This query selects all employees who have the highest salary in each department (`DepartmentID`), allowing for repetition if multiple employees have the same salary.
5. **Select Top 2 Salaries in Each Department (Using Dense Rank):**
    
    ```sql
    SELECT *
    FROM (
        SELECT *, DENSE_RANK() OVER (PARTITION BY DepartmentID ORDER BY Salary DESC) AS DR
        FROM Employees
    ) AS NewTable
    WHERE DR <= 2;
    
    ```
    
    - This query selects all employees who have the top 2 salaries in each department, including those with ties (i.e., if multiple employees have the same salary).
6. The query retrieves all employees who fall into the **first group** (quartile) when the employees are divided into **four equal groups** based on their `DepartmentID`, ordered in **descending order**.
    

```sql
SELECT *
FROM (
SELECT *, NTILE(4) OVER (ORDER BY DepartmentID DESC) AS G
FROM Employees
) AS NewTable
WHERE G = 1;
```

## 🔀 Conditional Logic

### ✅ CASE

```sql
SELECT Salary,
  CASE
    WHEN Salary <= 800 THEN 'low'
    WHEN Salary <= 1500 THEN 'medium'
    ELSE 'high'
  END AS Category
FROM Employees;
```

### ✅ IIF

```sql
SELECT IIF(Salary >= 1600, 'high', 'low') AS Category
FROM Employees;
```

## 🕗 Date & Time Formatting

### 📆 Convert with `CONVERT`

```sql
-- DD-MM-YYYY format
SELECT CONVERT(VARCHAR(20), GETDATE(), 105);
```

### 🎨 Format with `FORMAT()`

```sql
SELECT
  FORMAT(GETDATE(), 'yyyy-MM-dd') AS ISODate,
  FORMAT(GETDATE(), 'dd/MM/yyyy') AS CustomDate,
  FORMAT(GETDATE(), 'MMMM') AS MonthName,
  FORMAT(GETDATE(), 'dddd') AS DayName,
  FORMAT(GETDATE(), 'yyyy-MM-ddTHH:mm:ss.fff') AS ISODateTime,
  FORMAT(12345.6789, 'N2') AS FixedPoint;
```






---

# Lecture 6 

# SQL Server Database Architecture & Integrity

## Physical Representation

The physical representation refers to how data is stored on disk in actual files that make up the database.

### File Types

| File Type | Extension | Description                                                                         | Quantity         |
| --------- | --------- | ----------------------------------------------------------------------------------- | ---------------- |
| **MDF**   | `.mdf`    | Primary Data File - Contains main database data (tables, indexes)                   | 1 per database   |
| **NDF**   | `.ndf`    | Secondary Data File - Optional files for splitting data across multiple files/disks | Multiple allowed |
| **LDF**   | `.ldf`    | Transaction Log File - Records all transactions and modifications for recovery      | 1+ per database  |

### Database Creation Example

```sql
CREATE DATABASE MyDatabase
ON PRIMARY
( NAME = MyPrimaryFile,
  FILENAME = 'C:\MyData\MyPrimaryFile.mdf',
  SIZE = 5MB,
  MAXSIZE = 100MB,
  FILEGROWTH = 5MB )
LOG ON
( NAME = MyLogFile,
  FILENAME = 'C:\MyData\MyLogFile.ldf',
  SIZE = 1MB,
  MAXSIZE = 50MB,
  FILEGROWTH = 1MB );
```

## Logical Representation

The logical structure organizes data internally in the database, independent of physical storage.

### Filegroups

- **Filegroup**: Logical container for database files (grouping of MDF and NDF files)
- **Primary Filegroup**: Automatically created, contains primary data file (MDF) by default
- **Custom Filegroups**: Additional filegroups for organizing data into different locations

## Data Pages

- **Data pages** are **8 KB blocks** that store actual data for tables and indexes
- SQL Server uses various page types: data pages, index pages, large object pages
- Pages are grouped into **extents** for efficient management
- **Allocation maps** track which extents and pages are in use or available
- Pages are central to how SQL Server reads, writes, and manages data storage

## Benefit of Parallel Disk I/O

### How It Works

- By placing data files on **different physical disks**, SQL Server can perform **parallel I/O operations**
- Multiple files can be accessed simultaneously rather than sequentially
- Increases overall throughput for read/write operations

### Implementation

```sql
-- Example: Files on different drives
CREATE DATABASE ParallelDB
ON PRIMARY 
    (NAME = 'ParallelDB_Data1', FILENAME = 'C:\Data1\ParallelDB1.mdf'),
FILEGROUP Secondary
    (NAME = 'ParallelDB_Data2', FILENAME = 'D:\Data2\ParallelDB2.ndf'),
    (NAME = 'ParallelDB_Data3', FILENAME = 'E:\Data3\ParallelDB3.ndf');
```

## Performance Benefits of Filegroups

### Key Advantages

1. **Parallel Disk Access**
    
    - SQL Server can perform **parallel reads and writes** across different physical drives
    - Significantly speeds up queries and operations
2. **Improved Joins and Queries**
    
    - Tables stored in different filegroups (on separate drives) can be retrieved faster
    - Enhanced performance for complex operations
3. **Scalability**
    
    - Easier management of large databases by distributing load
    - Better resource utilization across multiple drives
4. **Backup and Restore Efficiency**
    
    - Can backup/restore individual filegroups instead of entire database
    - Faster backup/restore processes for large databases
5. **Enhanced Maintenance**
    
    - Index rebuilds and maintenance can be performed on specific filegroups
    - Reduced downtime during maintenance operations

## Create a Computed Column, Sparse, is Persisted

### Computed Columns

Columns whose values are calculated from expressions based on other columns.

```sql
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    Salary DECIMAL(10, 2),
    Overtime DECIMAL(10, 2),
    -- Computed column with PERSISTED (stored on disk)
    NetSalary AS (ISNULL(Salary, 0) + ISNULL(Overtime, 0)) PERSISTED,
    -- Computed column without PERSISTED (calculated on-the-fly)
    BD DATE,
    Age AS (YEAR(GETDATE()) - YEAR(BD))
);
```

### PERSISTED vs Non-PERSISTED

- **PERSISTED**: Computed value is **stored physically** on disk, improving query performance
- **Non-PERSISTED**: Value is **calculated each time** it's queried

### Sparse Columns

Optimized storage for columns with many NULL values.

```sql
CREATE TABLE Products (
    ProductID INT PRIMARY KEY,
    ProductName VARCHAR(100),
    -- Sparse column - NULLs take no storage space
    SpecialAttribute VARCHAR(50) SPARSE,
    OptionalField INT SPARSE
);
```

### When to Use Sparse

- Use when **40%+ of values are NULL**
- **NULL values consume no storage space**
- **Non-NULL values may require more storage** than regular columns
- Don't use if most values are non-NULL (increases storage)



## Reasons for Using Schemas

### 1. Unique Object Names

```sql
-- Same table name in different schemas
SELECT * FROM dbo.Employee;    -- Default schema
SELECT * FROM HR.Employee;     -- HR schema
SELECT * FROM Finance.Employee; -- Finance schema
```

### 2. Logical Grouping

- **HR Schema**: Employee tables, payroll, benefits
- **Finance Schema**: Accounting tables, budgets, expenses
- **Sales Schema**: Customer data, orders, products

### 3. Permission Management

```sql
-- Grant permissions at schema level instead of individual tables
GRANT SELECT ON SCHEMA::HR TO [HRRole];
GRANT INSERT, UPDATE ON SCHEMA::Finance TO [FinanceRole];
```

### Creating and Managing Schemas

```sql
-- Create schema
CREATE SCHEMA HR;

-- Transfer table to schema
ALTER SCHEMA HR TRANSFER dbo.Employee;

-- Create table in specific schema
CREATE TABLE HR.Benefits (
    BenefitID INT PRIMARY KEY,
    EmployeeID INT,
    BenefitType VARCHAR(50)
);
```

## Synonyms in SQL Server

### Purpose

Synonyms provide alternative names for database objects, simplifying queries and providing abstraction.

### Creating and Using Synonyms

```sql
-- Create synonym for complex schema.table reference
CREATE SYNONYM HREmployees FOR HR.Employee;
CREATE SYNONYM FinanceReports FOR Finance.MonthlyReports;

-- Use synonym instead of full name
SELECT * FROM HREmployees;  -- Instead of HR.Employee
SELECT * FROM FinanceReports; -- Instead of Finance.MonthlyReports
```

### Benefits

1. **Simplified References**: Shorter names for complex object references
2. **Abstraction Layer**: Change underlying object without updating all queries
3. **Easier Maintenance**: Update synonym definition instead of multiple references

### Managing Synonyms

```sql
-- Update synonym to point to different object
CREATE OR ALTER SYNONYM HREmployees FOR HR.NewEmployeeTable;

-- Drop synonym
DROP SYNONYM HREmployees;
```

## Deleting Data in Databases or Tables

### Comparison of Deletion Methods

| Operation    | Command                   | Speed | Structure     | Identity Reset | Rollback | WHERE Clause |
| ------------ | ------------------------- | ----- | ------------- | -------------- | -------- | ------------ |
| **DROP**     | `DROP TABLE Employee`     | Fast  | Removes table | N/A            | No       | No           |
| **DELETE**   | `DELETE FROM Employee`    | Slow  | Keeps table   | No             | Yes      | Yes          |
| **TRUNCATE** | `TRUNCATE TABLE Employee` | Fast  | Keeps table   | Yes            | No       | No           |
|              |                           |       |               |                |          |              |

### Detailed Examples

#### DROP TABLE

```sql
-- Completely removes table and all data
DROP TABLE Employee;
-- Table no longer exists in database
```

#### DELETE FROM

```sql
-- Delete specific rows
DELETE FROM Employee WHERE Salary < 1000;

-- Delete all rows (with WHERE condition)
DELETE FROM Employee WHERE 1=1;

-- Delete all rows (without WHERE - removes all data)
DELETE FROM Employee;
```

**Identity Behavior**: If you have identity values 1,2,3,4,5 and delete all rows, next insert will start from 6.

#### TRUNCATE TABLE

```sql
-- Quickly removes all rows, resets identity
TRUNCATE TABLE Employee;
```

**Identity Behavior**: Identity counter resets to beginning (next insert starts from 1).

### Clearing Specific Column Data

```sql
-- Clear column data without altering structure
UPDATE Employee SET ColumnName = NULL;
UPDATE Employee SET Address = NULL;
UPDATE Employee SET Address = 'N/A';  -- Set to specific value
```

| **Integrity Type**        | **Purpose**                                               | **Constraints**                                             | **Supporting Database Objects** |
| ------------------------- | --------------------------------------------------------- | ----------------------------------------------------------- | ------------------------------- |
| **Domain Integrity**      | Ensures data values fall within valid ranges and formats. | - Data Types- NOT NULL- DEFAULT values- CHECK constraints   | - Rules- Triggers               |
| **Entity Integrity**      | Ensures each row is uniquely identifiable.                | - PRIMARY KEY (unique + not null)- UNIQUE (allows one NULL) | - Indexes- Triggers             |
| **Referential Integrity** | Maintains valid relationships between tables.             | - FOREIGN KEY constraints                                   | - Triggers                      |

### Comprehensive Example

```sql
-- Create Department table
CREATE TABLE Department (
    Department_id INT PRIMARY KEY,
    Department_name VARCHAR(20)
);

-- Create Employee table with all constraint types
CREATE TABLE Employee (
    Employee_id INT IDENTITY(1, 2),              -- Auto-increment
    Employee_name VARCHAR(20),
    Employee_address VARCHAR(20) DEFAULT 'assuit', -- Default value
    hire_date DATE DEFAULT GETDATE(),             -- Default current date
    salary INT,
    overtime INT,
    -- Computed persisted column
    net_salary AS (ISNULL(salary, 0) + ISNULL(overtime, 0)) PERSISTED,
    BD DATE,
    -- Computed non-persisted column
    age AS (YEAR(GETDATE()) - YEAR(BD)),
    gender VARCHAR(1),
    hour_rate INT NOT NULL,                       -- Domain integrity
    department_id INT,

    -- Entity Integrity - Composite Primary Key
    CONSTRAINT PK_Employee PRIMARY KEY (Employee_id, Employee_name),
    
    -- Entity Integrity - Unique Constraints
    CONSTRAINT UQ_Salary UNIQUE (salary),
    CONSTRAINT UQ_Overtime UNIQUE (overtime),
    CONSTRAINT UQ_Salary_Overtime UNIQUE (salary, overtime), -- Composite unique
    
    -- Domain Integrity - Check Constraints
    CONSTRAINT CK_Salary CHECK (salary > 1200),
    CONSTRAINT CK_Address CHECK (Employee_address IN ('alex', 'cairo', 'sohag', 'assuit')),
    CONSTRAINT CK_Gender CHECK (gender IN ('M', 'F')),
    CONSTRAINT CK_Overtime CHECK (overtime BETWEEN 100 AND 500),
    
    -- Referential Integrity - Foreign Key
    CONSTRAINT FK_Department FOREIGN KEY (department_id)
        REFERENCES Department (Department_id)
        ON DELETE SET NULL
        ON UPDATE CASCADE
);
```

### Managing Constraints After Table Creation

```sql
-- Add constraints
ALTER TABLE Employee 
ADD CONSTRAINT CK_HourRate CHECK (hour_rate > 100);

-- Drop constraints
ALTER TABLE Employee 
DROP CONSTRAINT CK_HourRate;
```

### Foreign Key Cascade Options

- **ON DELETE SET NULL**: Sets foreign key to NULL when referenced record is deleted
- **ON DELETE CASCADE**: Deletes related records when referenced record is deleted
- **ON UPDATE CASCADE**: Updates foreign key when referenced primary key is updated
- **ON DELETE SET DEFAULT**: Sets foreign key to default value when referenced record is deleted

## Managing Rules, Defaults, and Data Types in SQL

### Creating and Managing Rules

Rules apply constraints to new data at the column level.

```sql
-- Create rule
CREATE RULE SalaryRule AS @x > 1200;

-- Bind rule to column
EXEC sp_bindrule 'SalaryRule', 'Employee.salary';

-- Unbind rule
EXEC sp_unbindrule 'Employee.salary';

-- Drop rule
DROP RULE SalaryRule;
```

### Creating and Managing Defaults

```sql
-- Create default
CREATE DEFAULT DefaultLocation AS 'Cairo';

-- Bind default to column
EXEC sp_bindefault 'DefaultLocation', 'Employee.Employee_address';

-- Unbind default
EXEC sp_unbindefault 'Employee.Employee_address';

-- Drop default
DROP DEFAULT DefaultLocation;
```

### Creating User-Defined Data Types

Combine rules, defaults, and data types into reusable components.

```sql
-- Step 1: Create default and rule
CREATE DEFAULT SalaryDefault AS 1200;
CREATE RULE SalaryRule AS @x > 1000;

-- Step 2: Create user-defined data type
EXEC sp_addtype 'SalaryType', 'int';

-- Step 3: Bind rule and default to data type
EXEC sp_bindrule 'SalaryRule', 'SalaryType';
EXEC sp_bindefault 'SalaryDefault', 'SalaryType';

-- Step 4: Use the custom data type
CREATE TABLE TestEmployee (
    EmployeeID INT PRIMARY KEY,
    Salary SalaryType  -- Uses custom data type with rule and default
);
```

### Rules vs Constraints Comparison

| Feature            | Rules                       | Constraints                         |
| ------------------ | --------------------------- | ----------------------------------- |
| **Scope**          | Single column               | One or more columns                 |
| **Quantity**       | One rule per column         | Multiple constraints per column     |
| **Precedence**     | Lower precedence            | Higher precedence (overrides rules) |
| **Reusability**    | Can be shared across tables | Table-specific                      |
| **Performance**    | Slower (separate objects)   | Faster (integrated)                 |
| **Recommendation** | Legacy support only         | Preferred for new development       |

### Key Points

- **Constraints take precedence over Rules** when both exist on same column
- **One Rule per column** maximum
- **Multiple Constraints per column** allowed
- Rules can be **shared between tables**
- Constraints are **table-specific**
- Use **Constraints for new development**, Rules only for legacy compatibility



---

# Lecture 7

# SQL Server Variables, Control Flow, Transaction & Functions - Summary

## Variables

### Local Variables

- **Declaration**: `DECLARE @x INT;`
- **Assignment**:
    - `SET @x = 10;`
    - `SELECT @x = 100;`
    - `SELECT @x = (SELECT AVG(Salary) FROM Employees);`
- **Table Variables**: `DECLARE @table TABLE (ID INT, Name VARCHAR(50));`

### Global Variables (System)

- `@@SERVERNAME` - Server name
- `@@ROWCOUNT` - Rows affected by last operation
- `@@VERSION` - SQL Server version
- `@@ERROR` - Last error number
- `@@IDENTITY` - Last inserted identity value

### Dynamic SQL

```sql
DECLARE @sql VARCHAR(100) = 'SELECT * FROM Employees';
EXEC(@sql);
-- Secure version with parameters
EXEC sp_executesql N'SELECT * FROM Employees WHERE ID = @id', N'@id INT', @id;
```

## Control Flow Statements

### IF Statement

```sql
IF @condition
    SELECT 'True';
ELSE
BEGIN
    SELECT 'False';
    SELECT 'Multiple statements need BEGIN/END';
END
```

### Existence Checks

```sql
IF EXISTS (SELECT * FROM sys.tables WHERE name = 'Employees')
    SELECT 'Table exists';

IF NOT EXISTS (SELECT * FROM Employees WHERE ID = 40)
    DELETE FROM Departments WHERE ID = 40;
```

### TRY...CATCH

```sql
BEGIN TRY
    DELETE FROM Departments WHERE ID = 10;
END TRY
BEGIN CATCH
    SELECT ERROR_MESSAGE(), ERROR_NUMBER(), ERROR_LINE();
END CATCH
```

### WHILE Loop

```sql
DECLARE @i INT = 1;
WHILE @i <= 10
BEGIN
    IF @i = 5 CONTINUE;  -- Skip iteration
    IF @i = 8 BREAK;     -- Exit loop
    SELECT @i;
    SET @i += 1;
END
```

### CASE Statement

```sql
UPDATE Employees
SET Salary = CASE 
    WHEN Salary <= 800 THEN Salary * 1.2
    WHEN Salary <= 1500 THEN Salary * 1.3
    ELSE Salary * 1.4
END;
```

### Conditional Functions

- `IIF(condition, true_value, false_value)`
- `CHOOSE(index, 'val1', 'val2', 'val3')`



## Transaction Overview

Understanding the distinction between batches, scripts, and transactions is crucial for effective SQL Server development and database management.

## Batch

A **batch** is a collection of SQL statements executed together as a single unit by SQL Server.

### Key Points:

- All statements in a batch are processed together
- Use `GO` keyword to separate batches
- Statements before `GO` execute before those after it

### Example:

```sql
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    Name VARCHAR(50)
);
GO
DROP TABLE Employees;  -- Executes after the previous batch
```

## Script

A **script** is a collection of SQL queries that may contain conflicting operations requiring separation.

### Key Points:

- Cannot run conflicting statements together (e.g., `CREATE TABLE` and `DROP TABLE`)
- Requires `GO` keyword to separate incompatible operations
- Operations execute sequentially in different batches

### Example:

```sql
CREATE RULE SalaryRule AS CHECK (Salary > 0);
GO
SP_BINDRULE Employees.Salary, SalaryRule;
```

## Transaction

A **transaction** ensures a series of SQL operations either all succeed or all fail, maintaining data integrity.

### Transaction Types:

#### 1. Implicit Transaction

- Every `INSERT`, `UPDATE`, or `DELETE` operates as its own transaction
- SQL Server automatically handles transaction boundaries
- Auto-commit or auto-rollback on errors

#### 2. Explicit Transaction

- Manually defined using `BEGIN TRANSACTION`, `COMMIT`, and `ROLLBACK`
- Full control over transaction boundaries
- Better for complex operations requiring atomicity

## Transaction Examples

### Basic Setup:

```sql
USE CompanyDB;

CREATE TABLE Parent (
    PID INT PRIMARY KEY
);

CREATE TABLE Child (
    CID INT REFERENCES Parent(PID)
);

INSERT INTO Parent VALUES (1), (2), (3), (4);
```

### Simple Explicit Transaction:

```sql
BEGIN TRANSACTION;
INSERT INTO Child VALUES (1);
INSERT INTO Child VALUES (2);
INSERT INTO Child VALUES (3);
ROLLBACK;  -- No data will be inserted
```

### Error Handling with TRY...CATCH:

```sql
BEGIN TRY
    BEGIN TRANSACTION;
    INSERT INTO Child VALUES (1);
    INSERT INTO Child VALUES (6);  -- May cause foreign key violation
    INSERT INTO Child VALUES (2);
    COMMIT;  -- Success: commit all changes
END TRY
BEGIN CATCH
    ROLLBACK;  -- Error: undo all changes
    SELECT ERROR_MESSAGE() AS ErrorMessage;
END CATCH;
```

## Key Differences Summary
| Term            | What It Is                                | Key Feature                  | Rollback Possible?                 |
| --------------- | ----------------------------------------- | ---------------------------- | ---------------------------------- |
| **Script**      | A set of SQL commands (e.g., `.sql` file) | Runs statements in order     | ❌ No (unless using transactions)   |
| **Batch**       | Group of SQL commands sent at once        | Ends with `GO` in SQL Server | ❌ No (unless inside a transaction) |
| **Transaction** | Logical unit of work                      | All-or-nothing execution     | ✅ Yes (commit/rollback)            |

## Transaction ACID Properties

- **Atomicity**: All operations succeed or all fail
- **Consistency**: Database remains in valid state
- **Isolation**: Concurrent transactions don't interfere
- **Durability**: Committed changes persist permanently


---

## Built-in Functions

### NULL Functions

- `ISNULL(expression, replacement)`
- `COALESCE(expr1, expr2, expr3, ...)` - First non-NULL
- `NULLIF(expr1, expr2)` - NULL if equal

### String Functions

- `SUBSTRING(string, start, length)`
- `UPPER(string)`, `LOWER(string)`
- `LEN(string)`

### Date Functions

- `GETDATE()` - Current datetime
- `YEAR(date)`, `MONTH(date)`, `DAY(date)`

### Conversion Functions

- `CONVERT(datatype, expression, style)`
- `CAST(expression AS datatype)`
- `FORMAT(value, format, culture)`

### Aggregate Functions

- `COUNT(*)`, `MAX()`, `MIN()`, `AVG()`, `SUM()`

### Window Functions

- `ROW_NUMBER() OVER (ORDER BY column)`
- `RANK() OVER (ORDER BY column)`
- `DENSE_RANK() OVER (ORDER BY column)`
- `LAG(column) OVER (ORDER BY column)` - Previous row
- `LEAD(column) OVER (ORDER BY column)` - Next row
- `FIRST_VALUE(column) OVER (ORDER BY column)`
- `LAST_VALUE(column) OVER (ORDER BY column ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)`



## LAG and LEAD Functions Overview

LAG and LEAD are powerful window functions in SQL Server that allow you to access data from previous or subsequent rows within a result set without using self-joins.

## Function Definitions

### LAG Function

- **Purpose**: Retrieves the value of a specified column from the **previous row** within the result set
- **Syntax**: `LAG(column_name, offset, default_value) OVER (ORDER BY column)`
- **Direction**: Looks backward in the result set

### LEAD Function

- **Purpose**: Retrieves the value of a specified column from the **next row** within the result set
- **Syntax**: `LEAD(column_name, offset, default_value) OVER (ORDER BY column)`
- **Direction**: Looks forward in the result set

## Basic Usage Examples

### 1. Getting Previous and Next Employee Names

Access employee names from adjacent rows based on salary ordering:

```sql
SELECT
    Lname,
    Salary,
    PrevLname = LAG(Lname) OVER (ORDER BY Salary),
    NextLname = LEAD(Lname) OVER (ORDER BY Salary)
FROM
    Employee;
```

**Result**: Shows each employee with their predecessor and successor names when ordered by salary.

### 2. Getting Previous and Next Salaries

Compare current salary with adjacent salary values:

```sql
SELECT
    Lname,
    Salary,
    PrevSalary = LAG(Salary) OVER (ORDER BY Salary),
    NextSalary = LEAD(Salary) OVER (ORDER BY Salary)
FROM
    Employee;
```

**Result**: Shows salary progression and allows for salary gap analysis.

## Advanced Usage Examples

### 3. Using Subquery for Specific Employee Analysis

Filter results to analyze a specific employee's position relative to others:

```sql
SELECT *
FROM (
    SELECT
        Lname,
        Salary,
        PrevLname = LAG(Lname) OVER (ORDER BY Salary),
        NextLname = LEAD(Lname) OVER (ORDER BY Salary)
    FROM
        Employee
) AS NewTable
WHERE
    Lname = 'Ahmed';
```

**Result**: Shows Ahmed's salary position and who earns just below and above him.

### 4. Using PARTITION BY for Department-wise Analysis

Apply LAG/LEAD within specific groups (departments):

```sql
SELECT
    Lname,
    Salary,
    Dno,
    PrevLname = LAG(Lname) OVER (PARTITION BY Dno ORDER BY Salary),
    NextLname = LEAD(Lname) OVER (PARTITION BY Dno ORDER BY Salary)
FROM
    Employee;
```

**Result**: Shows previous/next employees within each department, reset for each department.

## Function Parameters

|Parameter|Description|Required|
|---|---|---|
|`column_name`|Column to retrieve value from|Yes|
|`offset`|Number of rows to look back/forward (default: 1)|No|
|`default_value`|Value to return when no row exists (default: NULL)|No|

## Extended Examples with Parameters

### Using Offset Parameter

```sql
SELECT
    Lname,
    Salary,
    -- Get name from 2 rows back
    TwoRowsBack = LAG(Lname, 2) OVER (ORDER BY Salary),
    -- Get name from 2 rows forward
    TwoRowsForward = LEAD(Lname, 2) OVER (ORDER BY Salary)
FROM
    Employee;
```

### Using Default Value Parameter

```sql
SELECT
    Lname,
    Salary,
    -- Return 'N/A' when no previous row exists
    PrevLname = LAG(Lname, 1, 'N/A') OVER (ORDER BY Salary),
    -- Return 'HIGHEST' when no next row exists
    NextLname = LEAD(Lname, 1, 'HIGHEST') OVER (ORDER BY Salary)
FROM
    Employee;
```

## Practical Use Cases

### 1. Salary Gap Analysis

Calculate differences between consecutive salaries:

```sql
SELECT
    Lname,
    Salary,
    PrevSalary = LAG(Salary) OVER (ORDER BY Salary),
    SalaryIncrease = Salary - LAG(Salary) OVER (ORDER BY Salary)
FROM
    Employee;
```

### 2. Trend Analysis

Identify salary trends within departments:

```sql
SELECT
    Lname,
    Salary,
    Dno,
    PrevSalary = LAG(Salary) OVER (PARTITION BY Dno ORDER BY Salary),
    Trend = CASE 
        WHEN Salary > LAG(Salary) OVER (PARTITION BY Dno ORDER BY Salary) 
        THEN 'Higher' 
        ELSE 'Same/Lower' 
    END
FROM
    Employee;
```

### 3. Running Comparisons

Compare each employee with immediate neighbors:

```sql
SELECT
    Lname,
    Salary,
    PrevSalary = LAG(Salary) OVER (ORDER BY Salary),
    NextSalary = LEAD(Salary) OVER (ORDER BY Salary),
    IsMiddleValue = CASE 
        WHEN Salary BETWEEN 
            LAG(Salary) OVER (ORDER BY Salary) AND 
            LEAD(Salary) OVER (ORDER BY Salary) 
        THEN 'Yes' 
        ELSE 'No' 
    END
FROM
    Employee;
```

## Key Benefits

1. **Eliminates Self-Joins**: No need for complex self-join queries
2. **Better Performance**: More efficient than traditional approaches
3. **Cleaner Code**: More readable and maintainable SQL
4. **Flexible Grouping**: Works with PARTITION BY for group-wise analysis
5. **Handles NULLs**: Built-in NULL handling for boundary rows

## Important Notes

- **NULL Values**: First row has NULL for LAG, last row has NULL for LEAD (unless default specified)
- **Ordering**: Always requires ORDER BY clause within OVER()
- **Partitioning**: Use PARTITION BY to reset calculations within groups
- **Data Types**: Returned data type matches the source column
- **Performance**: Generally more efficient than correlated subqueries

## Common Patterns

| Pattern                                                | Use Case                   |
| ------------------------------------------------------ | -------------------------- |
| `LAG(column) OVER (ORDER BY date)`                     | Previous time period value |
| `LEAD(column) OVER (ORDER BY sequence)`                | Next sequential value      |
| `LAG(column) OVER (PARTITION BY group ORDER BY value)` | Previous within group      |
| `column - LAG(column) OVER (...)`                      | Calculate differences      |
| `LAG(column, 1, 0) OVER (...)`                         | Handle NULLs with default  |
## User-Defined Functions

### 1. Scalar Function (Returns single value)

```sql
CREATE FUNCTION dbo.GetEmployeeName(@id INT)
RETURNS VARCHAR(50)
AS
BEGIN
    DECLARE @name VARCHAR(50);
    SELECT @name = EmployeeName FROM Employees WHERE ID = @id;
    RETURN @name;
END;

-- Usage: SELECT dbo.GetEmployeeName(123);
```

### 2. Inline Table-Valued Function

```sql
CREATE FUNCTION dbo.GetDepartmentEmployees(@deptId INT)
RETURNS TABLE
AS
RETURN
(
    SELECT EmployeeName, Salary * 12 AS AnnualSalary
    FROM Employees
    WHERE DepartmentID = @deptId
);

-- Usage: SELECT * FROM dbo.GetDepartmentEmployees(10);
```

### 3. Multi-Statement Table-Valued Function

```sql
CREATE FUNCTION dbo.GetEmployeesByFormat(@format VARCHAR(20))
RETURNS @result TABLE (ID INT, Name VARCHAR(50))
AS
BEGIN
    IF @format = 'first'
        INSERT INTO @result SELECT ID, FirstName FROM Employees;
    ELSE IF @format = 'last'
        INSERT INTO @result SELECT ID, LastName FROM Employees;
    ELSE
        INSERT INTO @result SELECT ID, FirstName + ' ' + LastName FROM Employees;
    RETURN;
END;

-- Usage: SELECT * FROM dbo.GetEmployeesByFormat('full');
```

## Security Best Practices

### SQL Injection Prevention

❌ **Dangerous**:

```sql
EXEC('SELECT * FROM Users WHERE ID = ' + @userInput);
```

✅ **Safe**:

```sql
EXEC sp_executesql 
    N'SELECT * FROM Users WHERE ID = @id',
    N'@id INT',
    @userInput;
```

### Key Points

- Always validate user input
- Use parameterized queries
- Apply least privilege principle
- Never concatenate user input directly into SQL strings

## Quick Examples

### Get Employee with Longest Name

```sql
SELECT TOP 1 EmployeeName
FROM Employees
ORDER BY LEN(EmployeeName) DESC;
```

### Window Function Example

```sql
SELECT 
    EmployeeName,
    Salary,
    LAG(Salary) OVER (ORDER BY Salary) AS PrevSalary,
    LEAD(Salary) OVER (ORDER BY Salary) AS NextSalary,
    RANK() OVER (ORDER BY Salary DESC) AS SalaryRank
FROM Employees;
```

---

# Lecture 8

## SQL Server Indexes - Summary


## Storage Types Comparison

| Storage Type        | Organization            | Search Method           | Insert Speed | Use Case         |
| ------------------- | ----------------------- | ----------------------- | ------------ | ---------------- |
| **Heap**            | Unordered               | Table scan (every row)  | Very Fast    | No primary key   |
| **Clustered Index** | Physically sorted by PK | Binary search (B+ tree) | Medium       | With primary key |

## Index Types Comparison

|Feature|Clustered Index|Non-Clustered Index|
|---|---|---|
|**Quantity per table**|1 only|Up to 999|
|**Data location**|Leaf nodes = actual data|Leaf nodes = pointers to data|
|**Physical ordering**|Controls table's physical order|Separate from table order|
|**Disk space**|No extra space needed|Requires additional storage|
|**Creation**|Auto (PRIMARY KEY)|Manual or Auto (UNIQUE)|
|**Update impact**|High (may reorder data)|Low (index only)|
|**Memory usage**|Always loaded|Loaded when needed|

## Performance Comparison

| Operation         | Heap                | Clustered Index      | Non-Clustered Index      |
| ----------------- | ------------------- | -------------------- | ------------------------ |
| **Search**        | Slow (table scan)   | Fast (binary search) | Medium (index + pointer) |
| **Insert**        | Very Fast           | Medium               | Fast                     |
| **Range queries** | Slow                | Very Fast            | Medium                   |
| **Sorting**       | Needs external sort | Already sorted       | Needs additional sorting |

## Search Process Steps Comparison

|Step|Clustered Index Search|Non-Clustered Index Search|
|---|---|---|
|**1**|Navigate B+ tree structure|Check if column has non-clustered index|
|**2**|Compare values at each node|Navigate index B-tree structure|
|**3**|Reach leaf node with actual data|Compare ASCII values to find target|
|**4**|Return matching rows|Locate matching entries in index|
|**5**|✅ **Complete**|Use pointers to access full data from original pages|
|**6**|-|Return all matching rows|

## Search Efficiency Analysis

| Factor                  | Clustered Index                 | Non-Clustered Index                    |
| ----------------------- | ------------------------------- | -------------------------------------- |
| **Steps required**      | 4 steps                         | 6 steps                                |
| **Direct data access**  | ✅ Yes (leaf nodes contain data) | ❌ No (requires pointer lookup)         |
| **I/O operations**      | Lower                           | Higher (index + data page reads)       |
| **Network round trips** | Fewer                           | More (separate index and data access)  |
| **Best for**            | Single row or range lookups     | Selective filtering on non-key columns |
## When to Use Each Type

### ✅ Use Clustered Index For:

- Primary key columns
- Frequently searched columns
- Range queries (`BETWEEN`, `<`, `>`)
- `ORDER BY` operations
- High read-to-write ratio tables

### ✅ Use Non-Clustered Index For:

- Secondary search columns
- `WHERE` clause columns
- `JOIN` condition columns
- Frequently filtered columns

### ❌ Avoid Indexes When:

- Frequently updated columns
- Small tables
- Low selectivity columns
- High insert/update volume tables

## Quick SQL Examples

```sql
-- Clustered index (auto-created with PRIMARY KEY)
CREATE TABLE Employees (
    ID INT PRIMARY KEY,  -- Creates clustered index
    Name VARCHAR(50)
);

-- Non-clustered index (manual)
CREATE NONCLUSTERED INDEX idx_Name ON Employees(Name);

-- Clustered index (if no PK exists)
CREATE CLUSTERED INDEX idx_clustered ON Orders(OrderDate);

-- Non-clustered indexes
CREATE NONCLUSTERED INDEX idx_customer ON Orders(CustomerID);
CREATE NONCLUSTERED INDEX idx_status ON Orders(Status);

-- Composite index
CREATE NONCLUSTERED INDEX idx_composite ON Orders(CustomerID, OrderDate);

DROP INDEX idx_EmployeeName ON Employees;

-- View indexes
SELECT i.name, i.type_desc, c.name AS ColumnName
FROM sys.indexes i
JOIN sys.index_columns ic ON i.object_id = ic.object_id 
JOIN sys.columns c ON ic.object_id = c.object_id
WHERE i.object_id = OBJECT_ID('TableName');
```

## Key Points to Remember

1. **One clustered index maximum** per table
2. **PRIMARY KEY automatically creates** clustered index
3. **UNIQUE constraint automatically creates** non-clustered index
4. **Trade-off**: Faster reads vs slower writes
5. **Non-clustered indexes require additional storage**



--

## SQL Server Views - Summary


## What is a View?

A **View** is a virtual table that stores a SELECT statement, providing data abstraction, security, and query reusability.

## View Types

### Standard View (Virtual)

```sql
-- Basic view
CREATE VIEW VEmployee AS
SELECT * FROM Employees;

-- Filtered view with custom columns
CREATE VIEW VMale (name, id, salary) AS
SELECT Name, EmployeeID, Salary FROM Employees WHERE Sex = 'M';
```

### Indexed View (Physical Storage)

```sql
-- Requires SCHEMABINDING and unique clustered index
CREATE VIEW VDeptSalary WITH SCHEMABINDING AS
SELECT Dno, COUNT_BIG(*) AS EmpCount, SUM(Salary) AS TotalSal
FROM dbo.Employee GROUP BY Dno;

CREATE UNIQUE CLUSTERED INDEX IX_VDeptSalary ON VDeptSalary (Dno);
```

### Partitioned View

```sql
-- Combines data from multiple sources
CREATE VIEW VAllStudents AS
SELECT * FROM Server1.DB1.dbo.Students
UNION ALL
SELECT * FROM Server2.DB2.dbo.Students;
```

## Key Features

### Joining Tables

```sql
CREATE VIEW V_emp_dep AS
SELECT e.Name, d.DeptName, e.Salary
FROM Employee e JOIN Departments d ON e.Dno = d.Dnum;
```

### Security Options

```sql
-- Encrypted view (definition hidden)
CREATE VIEW VSecure WITH ENCRYPTION AS
SELECT * FROM Employees WHERE Salary > 50000;

-- Schema binding (locks table structure)
CREATE VIEW VBound WITH SCHEMABINDING AS
SELECT EmployeeID, Name FROM dbo.Employees;  -- Must use schema prefix
```

## DML Operations

### Single Table Views ✅

```sql
-- All DML operations allowed
INSERT INTO VMale VALUES ('John', 123, 5000);
UPDATE VMale SET Salary = 6000 WHERE EmployeeID = 123;
DELETE FROM VMale WHERE EmployeeID = 123;
```

**Requirements:** Non-selected columns must be identity, nullable, have defaults, or be calculated.

### Multi-Table Views ❌

- **DELETE**: Not allowed
- **INSERT/UPDATE**: Only if affecting single table columns

### WITH CHECK OPTION

```sql
CREATE VIEW VMaleOnly AS
SELECT * FROM Employee WHERE Sex = 'M'
WITH CHECK OPTION;  -- Prevents inserting females
```

## Performance Comparison

|Feature|Standard View|Indexed View|
|---|---|---|
|**Storage**|Virtual (no storage)|Physical storage|
|**Performance**|Query-dependent|Fast retrieval|
|**Schema Binding**|Optional|Required|
|**DML Overhead**|None|High maintenance|
|**Requirements**|Any SQL edition|Enterprise edition|

## Common Patterns

### Data Filtering

```sql
CREATE VIEW VActive AS
SELECT * FROM Employees WHERE Status = 'Active';
```

### Aggregation

```sql
CREATE VIEW VDeptStats AS
SELECT DeptID, COUNT(*) AS EmpCount, AVG(Salary) AS AvgSal
FROM Employees GROUP BY DeptID;
```

### Column Transformation

```sql
CREATE VIEW VFormatted AS
SELECT 
    EmployeeID,
    FirstName + ' ' + LastName AS FullName,
    DATEDIFF(YEAR, HireDate, GETDATE()) AS YearsEmployed
FROM Employees;
```

## Management Commands

```sql
-- View definition (if not encrypted)
EXEC sp_helptext 'ViewName';

-- Modify view
ALTER VIEW VEmployee AS SELECT * FROM Employees WHERE Active = 1;

-- Remove view
DROP VIEW VEmployee;
```

## Best Practices

**Use Views For:**

- Simplifying complex queries
- Restricting data access
- Creating reusable query patterns
- Abstracting database complexity

**Use Indexed Views For:**

- Frequently accessed aggregations
- Performance-critical complex joins
- Data warehouse scenarios

**Key Limitations:**

- Views cannot have parameters
- Multi-table DML restrictions
- Encrypted views cannot be decrypted
- Schema-bound views prevent table structure changes





----

# Lecture 9

## Stored Procedures

Query -> Parsing -> Optimize -> Query Tree -> Execution Plan

- Parsing => check if syntax is correct
- Optimize => check Metadata
- Query Tree => order of execution of the query
- Execution Plan => execute query in memory

Note : Every run to query pass throw to all this steps that is take a lot of time, network traffic here is why coming **stored procedures**

Saved Query Tree -> Execution Plan (memory) => **stored procedures**

**Advantages of Stored Procedures (Summary):**

1. **Faster Performance** – Precompiled and optimized by the database.
    
2. **Reusability** – Write once, use many times.
    
3. **Security** – Control access without exposing tables.
    
4. **Easy Maintenance** – Update logic in one place.
    
5. **Less Network Traffic** – Send one call instead of many queries.
    
6. **Modular Code** – Cleaner and more organized SQL logic.
    
7. **Error Handling** – Supports structured error control


### Types of Stored Procedures

1. **Built-in Procedures**: These are provided by SQL Server for specific database management tasks.
    - **Examples**:
        - `sp_bindrule`: Binds a rule to a column or user-defined data type.
        - `sp_unbindrule`: Unbinds a rule from a column or user-defined data type.
        - `sp_helpconstraint`: Displays information about constraints on a table.
        - `sp_rename`: Renames a database object like a table or a column.
        - `sp_addtype`: Creates a new user-defined data type.

2. **User-defined Procedures**: Custom procedures created by users for specific business logic and data manipulation.
    - **Basic Example**:
        
        ```sql
        CREATE PROCEDURE getemps
        AS
        SELECT * FROM Employee;
        ```
        
        - **Calling the Procedure**:
            - `EXECUTE getemps;` or `getemps;`
    - **Inserting Procedure Results into a Table**:
        
        ```sql
        INSERT INTO table4(SSN, Fname)
        EXECUTE getemps;
        ```
        
    - **Dynamic Stored Procedure with Parameters**:
        
        ```sql
        CREATE PROCEDURE getempbyGender @Gender VARCHAR(10)
        AS
        SELECT * FROM Employees WHERE Gender = @Gender;
        
        ```
        
        - **Usage**: `getempbyGender 'M'`
    - **Stored Procedure with Conditional Insert**:
        
        ```sql
        CREATE PROCEDURE insertemp1 @id INT, @name VARCHAR(20)
        AS
        IF NOT EXISTS (SELECT * FROM Employees WHERE id = @id AND name = @name)
            INSERT INTO Employees (id, name) VALUES (@id, @name);
        ELSE
            SELECT 'duplicated values';
        
        ```
        
        - **Usage**: `insertemp1 1, 'Amr'`
    - **Error Handling with `TRY...CATCH`**:
        
        ```sql
        CREATE PROCEDURE insertemp2 @id INT, @name VARCHAR(20)
        AS
        BEGIN TRY
            INSERT INTO Employees (id, name) VALUES (@id, @name);
        END TRY
        BEGIN CATCH
            SELECT 'duplicated values';
        END CATCH;
        ```
        
        - **Usage**: `insertemp2 2, 'Amr'`
    - **Procedures with Input Parameters and Defaults**:
        
        ```sql
        CREATE PROCEDURE getsum1 @x INT = 10, @y INT = 20
        AS
        SELECT @x + @y;
        ```
        
        - **Usage**: `getsum1;` (returns 30 by default) and
        - `getsum1 @x = 13, @y = 16` (returns 29 Calling parameter by Name)
        - `getsum1 3, 11` (return 14 Calling parameter by Position)
        - `getsum1 33` (returns 53)
    - **Procedures with Output Parameters**:
        
        ```sql
        ALTER PROCEDURE getname1 @id INT, @name VARCHAR(20) OUTPUT
        AS
        SELECT @name = name FROM omar WHERE id = @id;
        ```
        
        - **Usage**:
            
            ```sql
            DECLARE @x VARCHAR(20);
            EXECUTE getname1 2, @x OUTPUT;
            SELECT @x;
            ```
            
    - **Procedures with Multiple Output Parameters**:
        
        ```sql
        ALTER PROCEDURE getname @id INT, @name1 VARCHAR(20) OUTPUT, @name2 VARCHAR(20) OUTPUT
        AS
        SELECT @name1 = name, @name2 = name FROM omar WHERE id = @id;
        ```
        
        - **Usage**:
            
            ```sql
            DECLARE @x VARCHAR(20), @y VARCHAR(20);
            EXECUTE getname 2, @x OUTPUT, @y OUTPUT;
            SELECT @x, @y;
            ```
            
    - **Input and Output Parameters Combined**:
        
        ```sql
        CREATE PROCEDURE getdata @id INT OUTPUT, @name VARCHAR(20) OUTPUT
        AS
        SELECT @id = id, @name = name FROM Employees WHERE id = @id;
        ```
        
        - **Usage**: 
            
            ```sql
            DECLARE @x INT = 1, @y VARCHAR(20);
            EXECUTE getdata @x OUTPUT, @y OUTPUT;
            SELECT @x, @y;
            ```
            
    - **Dynamic SQL Execution in a Procedure**:
        
        ```sql
        CREATE PROCEDURE getalldata @col VARCHAR(20), @tab VARCHAR(20)
        AS
        EXECUTE ('SELECT ' + @col + ' FROM ' + @tab);
        ```
        
        - **Usage**: `getalldata 'id', 'omar';`
    - **Encrypting a Stored Procedure**:
        
        ```sql
        CREATE PROCEDURE getalldata @col VARCHAR(20), @tab VARCHAR(20)
        WITH ENCRYPTION
        AS
        EXECUTE ('SELECT ' + @col + ' FROM ' + @tab);
        ```
        
        - To prevent others from viewing the code, you can use `WITH ENCRYPTION`. After encrypting, commands like `sp_helptext 'getalldata'` will not reveal the code.



 What is Calling by Position?

Calling by position means passing arguments to a stored procedure **in the exact order** the parameters are defined.

```sql
CREATE PROCEDURE GetEmployeeDetails
    @EmpID INT,
    @EmpName NVARCHAR(50)
AS
BEGIN
    SELECT * FROM Employees
    WHERE EmpID = @EmpID AND EmpName = @EmpName;
END;

EXEC GetEmployeeDetails 101, 'Ali'; => calling by Position

EXEC GetEmployeeDetails @EmpName = 'Ali', @EmpID = 101; => calling by Name
```


- Return in Stored Procedure => use to tell about the behaviour of it like a status code

--


## Triggers

- Can not call
- Can not send parameter
- Triggers works with level of table and database
- work on insert update delete, cusz this what been logged in log file

### Types of Table-Level Triggers

1. **AFTER Triggers**: Execute after the specified operation (e.g., after `INSERT`, `UPDATE`, or `DELETE`).

2. **INSTEAD OF Triggers**: Execute in place of the specified operation, providing custom logic instead of the default database action.


Examples and Usage of Triggers
### 1. **AFTER INSERT Trigger**

```sql
CREATE TRIGGER message
ON Employees 
AFTER INSERT
AS
SELECT 'Welcom to Robot Company'
```

- This trigger displays "god bless you" after inserting a new row into the `omar` table.

### 2. **AFTER UPDATE Trigger**

```sql
CREATE TRIGGER message1
ON Employees
FOR UPDATE
AS
SELECT GETDATE()
```

- Executes the `GETDATE()` function, showing the current date and time whenever an update is made to `omar`.

### 3. **INSTEAD OF DELETE Trigger**

```sql
CREATE TRIGGER message2
ON Employees
INSTEAD OF DELETE
AS
SELECT 'you can not delete data ' + SUSER_NAME()
```

- Prevents deletion from `Employees`, instead displaying a message with the current user name.

### 4. **Read-Only Table Trigger**

```sql
CREATE TRIGGER message3
ON Employees
INSTEAD OF INSERT, UPDATE, DELETE
AS
SELECT 'Not allowed'
```

- Makes `Employees` read-only by blocking any insert, update, or delete operation, displaying "not allowed."

### Trigger Functionalities

### a. **Update-Specific Functionality**

```sql
CREATE TRIGGER message4
ON Employees
FOR UPDATE
AS
IF UPDATE(name)
   SELECT 'allowed' 
```

- Executes only if the `Employees` column is updated, showing "allowed" if so. Other updates produce no output.

### b. **Enable and Disable Triggers**

- Use `ALTER TABLE` to **disable** or **enable** triggers without dropping them:
    
    ```sql
    ALTER TABLE Employees DISABLE TRIGGER message3
    ALTER TABLE Employees ENABLE TRIGGER message3
    ```



### c. **Using the `INSERTED` and `DELETED` Tables**

- SQL Server automatically creates two temporary tables within triggers:
    - **`INSERTED`**: Holds new data after `INSERT` or `UPDATE`.
    - **`DELETED`**: Holds old data before `DELETE` or `UPDATE`.

```sql
CREATE TRIGGER message5
ON Employees
FOR UPDATE
AS
SELECT * FROM inserted    -- New row data after update
SELECT * FROM deleted     -- Previous row data before update
```

### d. **Conditional DELETE Trigger**

```sql
CREATE TRIGGER message6
ON Employees
FOR DELETE
AS
IF FORMAT(GETDATE(), 'dddd') = 'Monday'
BEGIN
   SELECT 'not allowed'
   --rollback
   INSERT INTO Employees SELECT * FROM deleted
END
```

- Prevents deletion on Mondays, restoring data from `deleted` if a delete operation is attempted.

### e. **Tracking Changes in a History Table**

- This trigger logs each update to a history table for audit purposes:

```sql
CREATE TABLE history (
   _user VARCHAR(20),
   _date DATE,
   _oldid INT,
   _newid INT
)

CREATE TRIGGER message7
ON Employees
INSTEAD OF UPDATE
AS
IF UPDATE(id)
BEGIN
   DECLARE @old INT, @new INT, @date1 DATE = GETDATE(), @nam VARCHAR(20) = SUSER_NAME()
   SELECT @old = id FROM deleted
   SELECT @new = id FROM inserted
   INSERT INTO history VALUES(@nam, @date1, @old, @new)
END
```

### f. **Using the `OUTPUT` Keyword in DML Statements**

- The `OUTPUT` clause can capture modified rows and display information during runtime:

```sql
DELETE FROM Employees
OUTPUT GETDATE(), deleted.name
WHERE id = 7

UPDATE Employees
SET age = 26
OUTPUT GETDATE(), deleted.name
WHERE id = 5

INSERT INTO Employees
OUTPUT 'Hello new partner'
VALUES (6, 'vesta', 21)
```

Triggers are special types of stored procedures in SQL that automatically execute in response to specific events on a table or view, such as `INSERT`, `UPDATE`, or `DELETE` operations.

----


# Lecture 10

## Cursor

 - how to deal with result set row by row like for loop


## Sample Table Setup

```sql
CREATE TABLE Employees (
    EmployeeID INT,
    FirstName VARCHAR(50),
    LastName VARCHAR(50),
    Department VARCHAR(50)
);

INSERT INTO Employees (EmployeeID, FirstName, LastName, Department)
VALUES
(1, 'John', 'Doe', 'Sales'),
(2, 'Jane', 'Smith', 'HR'),
(3, 'Mike', 'Johnson', 'IT');
```

## Cursor Steps Overview

![[Screenshot 2024-10-31 063808.png]]

## Basic Cursor Template

```sql
-- Step 1: Declare cursor
DECLARE employee_cursor CURSOR FOR
SELECT EmployeeID, FirstName, LastName
FROM Employees;

-- Step 2: Declare variables
DECLARE @EmployeeID INT;
DECLARE @FirstName VARCHAR(50);
DECLARE @LastName VARCHAR(50);

-- Step 3: Open cursor
OPEN employee_cursor;

-- Step 4: Fetch first row
FETCH NEXT FROM employee_cursor INTO @EmployeeID, @FirstName, @LastName;
-- Alternative: FETCH employee_cursor INTO @EmployeeID, @FirstName, @LastName;

-- Step 5: Loop through rows
WHILE @@FETCH_STATUS = 0
BEGIN
    -- Process data
    PRINT 'EmployeeID: ' + CAST(@EmployeeID AS VARCHAR) + ', Name: ' + @FirstName + ' ' + @LastName;
    
    -- Fetch next row
    FETCH NEXT FROM employee_cursor INTO @EmployeeID, @FirstName, @LastName;
END;

-- Step 6 & 7: Cleanup
CLOSE employee_cursor;
DEALLOCATE employee_cursor;
```

## Practical Examples

### Example 1: Simple Read-Only Cursor

```sql
DECLARE EmployeeCursor CURSOR FOR
    SELECT EmployeeID, FirstName
    FROM Employees
    FOR READ ONLY;

DECLARE @EmployeeID INT, @EmployeeName VARCHAR(50);

OPEN EmployeeCursor;
FETCH NEXT FROM EmployeeCursor INTO @EmployeeID, @EmployeeName;

WHILE @@FETCH_STATUS = 0
BEGIN
    PRINT CONCAT('EmployeeID: ', @EmployeeID, ', Name: ', @EmployeeName);
    FETCH NEXT FROM EmployeeCursor INTO @EmployeeID, @EmployeeName;
END;

CLOSE EmployeeCursor;
DEALLOCATE EmployeeCursor;
```

### Example 2: String Concatenation with Cursors

```sql
DECLARE EmployeeNameCursor CURSOR FOR
    SELECT Name
    FROM Employees
    WHERE Name IS NOT NULL
    FOR READ ONLY;

DECLARE @EmployeeName VARCHAR(50), @ConcatenatedNames VARCHAR(MAX) = '';

OPEN EmployeeNameCursor;
FETCH NEXT FROM EmployeeNameCursor INTO @EmployeeName;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET @ConcatenatedNames = CASE 
        WHEN @ConcatenatedNames = '' THEN @EmployeeName 
        ELSE CONCAT(@ConcatenatedNames, ', ', @EmployeeName) 
    END;
    FETCH NEXT FROM EmployeeNameCursor INTO @EmployeeName;
END;

CLOSE EmployeeNameCursor;
DEALLOCATE EmployeeNameCursor;

SELECT @ConcatenatedNames AS CommaSeparatedNames;
```

### Example 3: Conditional Updates Using Cursors

```sql
DECLARE SalaryUpdateCursor CURSOR FOR
    SELECT Salary
    FROM Employees
    FOR UPDATE;

DECLARE @Salary DECIMAL(18, 2);

OPEN SalaryUpdateCursor;
FETCH NEXT FROM SalaryUpdateCursor INTO @Salary;

WHILE @@FETCH_STATUS = 0
BEGIN
    IF @Salary < 2000
        UPDATE Employees SET Salary = @Salary * 1.20 WHERE CURRENT OF SalaryUpdateCursor;
    ELSE
        UPDATE Employees SET Salary = @Salary * 1.10 WHERE CURRENT OF SalaryUpdateCursor;

    FETCH NEXT FROM SalaryUpdateCursor INTO @Salary;
END;

CLOSE SalaryUpdateCursor;
DEALLOCATE SalaryUpdateCursor;
```

### Example 4: Sequential Pattern Matching

```sql
DECLARE NameSequenceCursor CURSOR FOR
    SELECT Name
    FROM Employees
    FOR READ ONLY;

DECLARE @CurrentName VARCHAR(50), @PreviousName VARCHAR(50) = '', @MostafaAfterOmarCount INT = 0;

OPEN NameSequenceCursor;
FETCH NEXT FROM NameSequenceCursor INTO @CurrentName;

WHILE @@FETCH_STATUS = 0
BEGIN
    IF @PreviousName = 'omar' AND @CurrentName = 'mostafa'
        SET @MostafaAfterOmarCount += 1;

    SET @PreviousName = @CurrentName;
    FETCH NEXT FROM NameSequenceCursor INTO @CurrentName;
END;

CLOSE NameSequenceCursor;
DEALLOCATE NameSequenceCursor;

SELECT @MostafaAfterOmarCount AS MostafaAfterOmarCount;
```

## Key Points

- **@@FETCH_STATUS**: Critical for loop control (0=success, 1=no more rows, 2=invalid)
- **FOR READ ONLY**: Prevents accidental updates
- **FOR UPDATE**: Enables `WHERE CURRENT OF` updates
- **CURRENT OF**: Updates the exact row the cursor is positioned on
- Always **CLOSE** and **DEALLOCATE** cursors to free resources
- Use **PRINT** or **SET** for processing fetched data


---

# Topics


 - [x] ERD, Keys, Relationships, Mapping, SQL Languages => lec 1, 2
 - [x] normalization, joins, SQL Aggregate Functions, Subqueries & Set Operations => lec 3, 4 
 - [x] Execution Order, windowing ranking function, constrains, rules , delete, drop, truncate, schemes => 5, 6
 - [x] Variables, Control Flow & Functions, lag, lead, view, index => lecture 7, 8
 - [x] Stored Procedures, Triggers, Cursor => lecture 9, 10
